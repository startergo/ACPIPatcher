name: Build and Test ACPIPatcher

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      debug_level:
        description: 'Debug Level (1-4)'
        required: false
        default: '3'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'

env:
  EDK2_VERSION: edk2-stable202405
  DEBUG_LEVEL: ${{ github.event.inputs.debug_level || '3' }}

jobs:
  build-linux:
    name: Build on Ubuntu (GCC5)
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        arch: [X64, IA32]
        build_type: [RELEASE, DEBUG]
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential nasm uuid-dev gcc-multilib
    
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v3
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-ubuntu-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          git submodule update --init --recommend-shallow || echo "Warning: Some submodules failed to initialize"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      run: |
        cp -r acpipatcher/ACPIPatcherPkg edk2/
    
    - name: Setup EDK2 Environment
      run: |
        cd edk2
        . edksetup.sh
        make -C BaseTools
    
    - name: Build ACPIPatcher
      run: |
        cd edk2
        . edksetup.sh
        
        # Build with custom debug level
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t GCC5 \
              -p ACPIPatcherPkg/ACPIPatcherPkg.dsc \
              -D DEBUG_LEVEL=${{ env.DEBUG_LEVEL }}
    
    - name: Verify Build Output
      run: |
        cd edk2
        
        echo "Exploring actual build directory structure..."
        echo "=== Top-level Build directory ==="
        ls -la Build/ || echo "No Build directory found"
        
        echo "=== All subdirectories in Build/ ==="
        find Build/ -type d -name "*ACPIPatcher*" 2>/dev/null || echo "No ACPIPatcher directories found"
        
        echo "=== All .efi files in Build/ ==="
        find Build/ -name "*.efi" 2>/dev/null || echo "No .efi files found"
        
        # Try the expected path first
        BUILD_DIR="Build/ACPIPatcherPkg/${{ matrix.build_type }}_GCC5/${{ matrix.arch }}"
        echo "=== Checking expected path: $BUILD_DIR ==="
        ls -la "$BUILD_DIR/" || echo "Expected path not found"
        
        # Find the actual path to .efi files
        echo "=== Finding actual .efi file locations ==="
        EFI_PATHS=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null || true)
        DXE_PATHS=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null || true)
        
        if [ -n "$EFI_PATHS" ]; then
          echo "✅ Found ACPIPatcher.efi at:"
          echo "$EFI_PATHS"
          for path in $EFI_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcher.efi not found anywhere"
          exit 1
        fi
        
        if [ -n "$DXE_PATHS" ]; then
          echo "✅ Found ACPIPatcherDxe.efi at:"
          echo "$DXE_PATHS"
          for path in $DXE_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcherDxe.efi not found anywhere"
          exit 1
        fi
    
    - name: Create Distribution Package
      run: |
        cd edk2
        DIST_DIR="ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-linux"
        
        # Find the actual paths to .efi files
        EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
        DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
        
        if [ -z "$EFI_PATH" ] || [ -z "$DXE_PATH" ]; then
          echo "❌ Could not find .efi files for distribution package"
          exit 1
        fi
        
        mkdir -p "$DIST_DIR"
        cp "$EFI_PATH" "$DIST_DIR/"
        cp "$DXE_PATH" "$DIST_DIR/"
        
        # Copy documentation and test files using dynamic path discovery
        echo "Copying documentation and test files..."
        
        # Find the actual path to the source repository
        SOURCE_PATH="../acpipatcher"
        if [ ! -d "$SOURCE_PATH" ]; then
          SOURCE_PATH="$(find .. -name "ACPIPatcherPkg" -type d | head -1 | xargs dirname)"
        fi
        
        if [ -d "$SOURCE_PATH/Build/ACPI" ]; then
          cp -r "$SOURCE_PATH/Build/ACPI" "$DIST_DIR/" || echo "Warning: Could not copy ACPI test files"
        else
          echo "Warning: ACPI test directory not found at $SOURCE_PATH/Build/ACPI"
        fi
        
        if [ -f "$SOURCE_PATH/README.md" ]; then
          cp "$SOURCE_PATH/README.md" "$DIST_DIR/"
        else
          echo "Warning: README.md not found at $SOURCE_PATH/README.md"
        fi
        
        if [ -f "$SOURCE_PATH/DEBUG_GUIDE.md" ]; then
          cp "$SOURCE_PATH/DEBUG_GUIDE.md" "$DIST_DIR/" || echo "Warning: Could not copy DEBUG_GUIDE.md"
        else
          echo "Warning: DEBUG_GUIDE.md not found"
        fi
        
        if [ -f "$SOURCE_PATH/IMPROVEMENTS.md" ]; then
          cp "$SOURCE_PATH/IMPROVEMENTS.md" "$DIST_DIR/" || echo "Warning: Could not copy IMPROVEMENTS.md"
        else
          echo "Warning: IMPROVEMENTS.md not found"
        fi
        
        # Create version info
        echo "ACPIPatcher Build Information" > "$DIST_DIR/BUILD_INFO.txt"
        echo "============================" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Version: $(git -C ../acpipatcher describe --tags --always)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Commit: $(git -C ../acpipatcher rev-parse HEAD)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Date: $(date -u)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Architecture: ${{ matrix.arch }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Type: ${{ matrix.build_type }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Debug Level: ${{ env.DEBUG_LEVEL }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Toolchain: GCC5" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Platform: Ubuntu Linux" >> "$DIST_DIR/BUILD_INFO.txt"
        
        tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
    
    - name: Validate Build Artifacts
      run: |
        cd edk2
        
        # Run comprehensive build validation
        if [ -f "../acpipatcher/.github/scripts/test-build-artifacts.sh" ]; then
          echo "Running comprehensive build artifact validation..."
          bash ../acpipatcher/.github/scripts/test-build-artifacts.sh "$(pwd)" "${{ matrix.arch }}" "${{ matrix.build_type }}" "GCC5" || {
            echo "❌ Build artifact validation failed"
            exit 1
          }
        else
          echo "Validation script not found, running basic checks..."
          BUILD_DIR="Build/ACPIPatcherPkg/${{ matrix.build_type }}_GCC5/${{ matrix.arch }}"
          
          if [ -f "$BUILD_DIR/ACPIPatcher.efi" ] && [ -f "$BUILD_DIR/ACPIPatcherDxe.efi" ]; then
            echo "✅ Basic validation passed - required EFI files present"
          else
            echo "❌ Basic validation failed - required EFI files missing"
            exit 1
          fi
        fi
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-linux
        path: edk2/ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-linux.tar.gz
        retention-days: 30

  build-macos:
    name: Build on macOS (Xcode)
    runs-on: macos-13
    
    strategy:
      matrix:
        arch: [X64]
        build_type: [RELEASE, DEBUG]
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install Dependencies
      run: |
        brew install nasm mtoc
    
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v3
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-macos-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          git submodule update --init --recommend-shallow || echo "Warning: Some submodules failed to initialize"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      run: |
        cp -r acpipatcher/ACPIPatcherPkg edk2/
    
    - name: Setup EDK2 Environment
      run: |
        cd edk2
        . edksetup.sh
        make -C BaseTools
    
    - name: Build ACPIPatcher
      run: |
        cd edk2
        . edksetup.sh
        
        # Build with custom debug level
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t XCODE5 \
              -p ACPIPatcherPkg/ACPIPatcherPkg.dsc \
              -D DEBUG_LEVEL=${{ env.DEBUG_LEVEL }}
    
    - name: Verify Build Output
      run: |
        cd edk2
        
        echo "Exploring actual build directory structure..."
        echo "=== Top-level Build directory ==="
        ls -la Build/ || echo "No Build directory found"
        
        echo "=== All subdirectories in Build/ ==="
        find Build/ -type d -name "*ACPIPatcher*" 2>/dev/null || echo "No ACPIPatcher directories found"
        
        echo "=== All .efi files in Build/ ==="
        find Build/ -name "*.efi" 2>/dev/null || echo "No .efi files found"
        
        # Try the expected path first
        BUILD_DIR="Build/ACPIPatcherPkg/${{ matrix.build_type }}_XCODE5/${{ matrix.arch }}"
        echo "=== Checking expected path: $BUILD_DIR ==="
        ls -la "$BUILD_DIR/" || echo "Expected path not found"
        
        # Find the actual path to .efi files
        echo "=== Finding actual .efi file locations ==="
        EFI_PATHS=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null || true)
        DXE_PATHS=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null || true)
        
        if [ -n "$EFI_PATHS" ]; then
          echo "✅ Found ACPIPatcher.efi at:"
          echo "$EFI_PATHS"
          for path in $EFI_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcher.efi not found anywhere"
          exit 1
        fi
        
        if [ -n "$DXE_PATHS" ]; then
          echo "✅ Found ACPIPatcherDxe.efi at:"
          echo "$DXE_PATHS"
          for path in $DXE_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcherDxe.efi not found anywhere"
          exit 1
        fi
    
    - name: Create Distribution Package
      run: |
        cd edk2
        DIST_DIR="ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-macos"
        
        # Find the actual paths to .efi files
        EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
        DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
        
        if [ -z "$EFI_PATH" ] || [ -z "$DXE_PATH" ]; then
          echo "❌ Could not find .efi files for distribution package"
          exit 1
        fi
        
        mkdir -p "$DIST_DIR"
        cp "$EFI_PATH" "$DIST_DIR/"
        cp "$DXE_PATH" "$DIST_DIR/"
        
        # Copy documentation and test files using dynamic path discovery
        echo "Copying documentation and test files..."
        
        # Find the actual path to the source repository
        SOURCE_PATH="../acpipatcher"
        if [ ! -d "$SOURCE_PATH" ]; then
          SOURCE_PATH="$(find .. -name "ACPIPatcherPkg" -type d | head -1 | xargs dirname)"
        fi
        
        if [ -d "$SOURCE_PATH/Build/ACPI" ]; then
          cp -r "$SOURCE_PATH/Build/ACPI" "$DIST_DIR/" || echo "Warning: Could not copy ACPI test files"
        else
          echo "Warning: ACPI test directory not found at $SOURCE_PATH/Build/ACPI"
        fi
        
        if [ -f "$SOURCE_PATH/README.md" ]; then
          cp "$SOURCE_PATH/README.md" "$DIST_DIR/"
        else
          echo "Warning: README.md not found at $SOURCE_PATH/README.md"
        fi
        
        if [ -f "$SOURCE_PATH/DEBUG_GUIDE.md" ]; then
          cp "$SOURCE_PATH/DEBUG_GUIDE.md" "$DIST_DIR/" || echo "Warning: Could not copy DEBUG_GUIDE.md"
        else
          echo "Warning: DEBUG_GUIDE.md not found"
        fi
        
        if [ -f "$SOURCE_PATH/IMPROVEMENTS.md" ]; then
          cp "$SOURCE_PATH/IMPROVEMENTS.md" "$DIST_DIR/" || echo "Warning: Could not copy IMPROVEMENTS.md"
        else
          echo "Warning: IMPROVEMENTS.md not found"
        fi
        
        # Create version info
        echo "ACPIPatcher Build Information" > "$DIST_DIR/BUILD_INFO.txt"
        echo "============================" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Version: $(git -C ../acpipatcher describe --tags --always)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Commit: $(git -C ../acpipatcher rev-parse HEAD)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Date: $(date -u)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Architecture: ${{ matrix.arch }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Type: ${{ matrix.build_type }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Debug Level: ${{ env.DEBUG_LEVEL }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Toolchain: XCODE5" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Platform: macOS" >> "$DIST_DIR/BUILD_INFO.txt"
        
        tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
    
    - name: Validate Build Artifacts
      run: |
        cd edk2
        
        # Run comprehensive build validation
        if [ -f "../acpipatcher/.github/scripts/test-build-artifacts.sh" ]; then
          echo "Running comprehensive build artifact validation..."
          bash ../acpipatcher/.github/scripts/test-build-artifacts.sh "$(pwd)" "${{ matrix.arch }}" "${{ matrix.build_type }}" "XCODE5" || {
            echo "❌ Build artifact validation failed"
            exit 1
          }
        else
          echo "Validation script not found, running basic checks..."
          
          # Find actual .efi file paths
          EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
          DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
          
          if [ -n "$EFI_PATH" ] && [ -n "$DXE_PATH" ]; then
            echo "✅ Basic validation passed - required EFI files present"
            echo "  ACPIPatcher.efi: $EFI_PATH"
            echo "  ACPIPatcherDxe.efi: $DXE_PATH"
          else
            echo "❌ Basic validation failed - required EFI files missing"
            exit 1
          fi
        fi
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-macos
        path: edk2/ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-macos.tar.gz
        retention-days: 30

  build-windows:
    name: Build on Windows (VS2022)
    runs-on: windows-latest
    
    strategy:
      matrix:
        arch: [X64, IA32]
        build_type: [RELEASE, DEBUG]
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install NASM
      run: |
        choco install nasm -y
        
        # Show where Chocolatey installed NASM
        echo "Checking NASM installation locations..."
        Get-ChildItem "C:\ProgramData\chocolatey\lib\nasm" -Recurse -Filter "nasm.exe" -ErrorAction SilentlyContinue | Select-Object FullName
        
        # Find and add NASM to PATH for this session
        $possiblePaths = @(
          "C:\ProgramData\chocolatey\lib\nasm\tools",
          "C:\ProgramData\chocolatey\bin",
          "C:\tools\nasm",
          "C:\Program Files\NASM"
        )
        
        $nasmFound = $false
        foreach ($path in $possiblePaths) {
          if (Test-Path "$path\nasm.exe") {
            $env:PATH = "$path;$env:PATH"
            echo "Found and added NASM to PATH: $path"
            
            # Set GitHub environment variable to persist across steps
            echo "$path" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
            echo "Added to GITHUB_PATH: $path"
            $nasmFound = $true
            break
          }
        }
        
        if (-not $nasmFound) {
          echo "WARNING: NASM not found in standard locations"
          echo "Searching entire system for nasm.exe..."
          Get-ChildItem C:\ -Recurse -Filter "nasm.exe" -ErrorAction SilentlyContinue | Select-Object FullName
        }
        
        # Try to verify NASM installation
        try {
          nasm -v
          echo "✅ NASM is accessible"
        } catch {
          echo "⚠️ NASM verification failed, but it may still work in build environment"
        }
    
    - name: Setup Visual Studio Environment
      uses: microsoft/setup-msbuild@v1.3
      
    - name: Setup Windows Build Environment
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64
    
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v3
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-windows-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      shell: bash
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          git submodule update --init --recommend-shallow || echo "Warning: Some submodules failed to initialize"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      run: |
        xcopy /E /I acpipatcher\ACPIPatcherPkg edk2\ACPIPatcherPkg
    
    - name: Setup EDK2 Environment and Build
      shell: cmd
      run: |
        cd edk2
        
        REM ====================================================================
        REM CRITICAL: Set up NASM PATH before any EDK2 operations
        REM ====================================================================
        echo Setting up NASM environment...
        
        REM Check multiple possible NASM installation locations
        if exist "C:\ProgramData\chocolatey\lib\nasm\tools\nasm.exe" (
          set "NASM_PREFIX=C:\ProgramData\chocolatey\lib\nasm\tools\"
          set "PATH=C:\ProgramData\chocolatey\lib\nasm\tools;%PATH%"
          echo ✅ Found NASM at C:\ProgramData\chocolatey\lib\nasm\tools\
        ) else if exist "C:\ProgramData\chocolatey\bin\nasm.exe" (
          set "NASM_PREFIX=C:\ProgramData\chocolatey\bin\"
          set "PATH=C:\ProgramData\chocolatey\bin;%PATH%"
          echo ✅ Found NASM at C:\ProgramData\chocolatey\bin\
        ) else if exist "C:\tools\nasm\nasm.exe" (
          set "NASM_PREFIX=C:\tools\nasm\"
          set "PATH=C:\tools\nasm;%PATH%"
          echo ✅ Found NASM at C:\tools\nasm\
        ) else if exist "C:\Program Files\NASM\nasm.exe" (
          set "NASM_PREFIX=C:\Program Files\NASM\"
          set "PATH=C:\Program Files\NASM;%PATH%"
          echo ✅ Found NASM at C:\Program Files\NASM\
        ) else (
          echo ⚠️ NASM not found in standard locations, setting default...
          set "NASM_PREFIX=C:\ProgramData\chocolatey\lib\nasm\tools\"
        )
        
        REM Verify NASM is accessible
        nasm -v >nul 2>&1
        if errorlevel 1 (
          echo ❌ NASM verification failed - this may cause build issues
          echo Searching for NASM in additional locations...
          where nasm 2>nul || echo NASM not found in PATH
        ) else (
          echo ✅ NASM is accessible and ready
        )
        
        REM Set required environment variables to avoid warnings
        REM NASM Detection - Chocolatey usually installs to C:\ProgramData\chocolatey\bin
        where nasm >nul 2>&1
        if errorlevel 1 (
          REM If not in PATH, check common Chocolatey installation location first
          if exist "%ProgramData%\chocolatey\bin\nasm.exe" (
            set "NASM_PREFIX=%ProgramData%\chocolatey\bin\"
            set "PATH=%ProgramData%\chocolatey\bin;%PATH%"
            echo Found NASM at %ProgramData%\chocolatey\bin\
            echo Set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\tools\nasm\nasm.exe" (
            set "NASM_PREFIX=C:\tools\nasm\"
            set "PATH=C:\tools\nasm;%PATH%"
            echo Found NASM at C:\tools\nasm\
            echo Set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\Program Files\NASM\nasm.exe" (
            set "NASM_PREFIX=C:\Program Files\NASM\"
            set "PATH=C:\Program Files\NASM;%PATH%"
            echo Found NASM at C:\Program Files\NASM\
            echo Set NASM_PREFIX=%NASM_PREFIX%
          ) else (
            echo Warning: NASM not found in standard locations
            echo Setting default NASM_PREFIX to suppress warning
            set "NASM_PREFIX=C:\tools\nasm\"
          )
        ) else (
          echo NASM found in PATH
          REM Get the directory where NASM is located
          for /f "tokens=*" %%i in ('where nasm') do (
            set "NASM_PATH=%%i"
            goto :found_nasm
          )
          :found_nasm
          for %%i in ("%NASM_PATH%") do set "NASM_PREFIX=%%~dpi"
          echo Set NASM_PREFIX=%NASM_PREFIX%
        )
        
        REM Set CLANG_BIN if LLVM is available
        if exist "C:\Program Files\LLVM\bin\clang.exe" (
          set "CLANG_BIN=C:\Program Files\LLVM\bin\"
          echo Set CLANG_BIN=%CLANG_BIN%
        )
        
        REM CYGWIN_HOME is not needed for VS2022 builds, suppress warning
        set "CYGWIN_HOME="
        
        REM CRITICAL FIX: Set WORKSPACE and call edksetup.bat FIRST to set BASE_TOOLS_PATH
        echo Setting up EDK2 environment BEFORE BaseTools build...
        
        REM Use GitHub-provided workspace path for EDK2
        set "WORKSPACE=%GITHUB_WORKSPACE%\edk2"
        echo Set WORKSPACE to: %WORKSPACE%
        
        call edksetup.bat
        
        REM Verify BASE_TOOLS_PATH is set
        echo Verifying BASE_TOOLS_PATH environment variable...
        if "%BASE_TOOLS_PATH%"=="" (
          echo WARNING: BASE_TOOLS_PATH not set by edksetup, setting manually...
          set "BASE_TOOLS_PATH=%WORKSPACE%\BaseTools"
          echo Set BASE_TOOLS_PATH to: %BASE_TOOLS_PATH%
        ) else (
          echo BASE_TOOLS_PATH is: %BASE_TOOLS_PATH%
        )
        
        REM Build BaseTools AFTER setting BASE_TOOLS_PATH
        echo Building BaseTools for Windows...
        cd BaseTools
        python -m pip install --upgrade pip
        
        REM Set environment to completely disable warnings for BaseTools build
        REM We need to override the hardcoded /W4 /WX flags in the nmake files
        set CL=/W0
        set LINK=/IGNORE:4099
        echo Building BaseTools with all warnings disabled...
        
        REM Try standard build first
        nmake 2>build_warnings.log
        if errorlevel 1 (
          echo Standard BaseTools build failed, trying with enhanced warning suppression...
          type build_warnings.log
          echo.
          
          REM Clean and try with enhanced suppression
          nmake clean >nul 2>&1
          
          REM More aggressive approach: modify CFLAGS directly to override hardcoded flags
          set CFLAGS=/nologo /Z7 /c /O2 /MT /W0 /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE
          set CL=/W0
          
          echo Attempting BaseTools build with overridden CFLAGS...
          nmake CFLAGS="%CFLAGS%"
          if errorlevel 1 (
            echo Enhanced build failed, trying Python fallback with modified environment...
            
            REM Try to patch the nmake files to remove /WX
            if exist "Makefiles\ms.common" (
              echo Patching ms.common to remove /WX...
              powershell -Command "(Get-Content 'Makefiles\ms.common') -replace '/W4 /WX', '/W0' | Set-Content 'Makefiles\ms.common'"
            )
            
            python Makefiles\NmakeSubdirs.py all
            if errorlevel 1 (
              echo All BaseTools build methods failed
              type build_warnings.log
              exit /b 1
            )
          )
        )
        
        REM Enhanced post-build verification and tool location
        echo Performing enhanced BaseTools verification...
        if not exist "Bin\Win32" (
          echo Creating missing Bin\Win32 directory...
          mkdir "Bin\Win32" 2>nul
        )
        
        REM Check if tools were built in alternative locations and copy them
        echo Searching for built tools in alternative locations...
        if exist "Bin\*.exe" (
          echo Copying tools from Bin\ to Bin\Win32\...
          copy "Bin\*.exe" "Bin\Win32\" >nul 2>&1
        )
        
        REM Some tools might be in the root BaseTools directory
        if exist "*.exe" (
          echo Copying tools from BaseTools root to Bin\Win32\...
          copy "*.exe" "Bin\Win32\" >nul 2>&1
        )
        
        REM Check Source\C subdirectories for built tools
        for /d %%D in (Source\C\*) do (
          if exist "%%D\*.exe" (
            echo Copying tools from %%D\ to Bin\Win32\...
            copy "%%D\*.exe" "Bin\Win32\" >nul 2>&1
          )
        )
        
        REM Check individual tool directories
        if exist "Source\C\VfrCompile\*.exe" copy "Source\C\VfrCompile\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\VolInfo\*.exe" copy "Source\C\VolInfo\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\GenFv\*.exe" copy "Source\C\GenFv\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\GenFfs\*.exe" copy "Source\C\GenFfs\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\GenSec\*.exe" copy "Source\C\GenSec\*.exe" "Bin\Win32\" >nul 2>&1
        
        REM Verify that critical tools exist
        echo Final verification of BaseTools...
        if exist "Bin\Win32\build.exe" (
          echo ✅ build.exe found in Bin\Win32
        ) else (
          echo ⚠️  build.exe not found in Bin\Win32, checking alternatives...
          if exist "Source\Python\build\build.py" (
            echo ✅ Found Python build script as alternative
          ) else (
            echo ❌ Neither build.exe nor build.py found - this may cause issues
          )
        )
        
        echo Listing contents of Bin\Win32:
        dir "Bin\Win32" 2>nul || echo No files in Bin\Win32 directory
        
        echo ✅ BaseTools build completed
        cd ..
        
        REM Re-establish environment variables before calling edksetup.bat
        echo Re-establishing environment variables before EDK2 setup...
        
        REM Re-detect and set NASM_PREFIX
        where nasm >nul 2>&1
        if errorlevel 1 (
          if exist "%ProgramData%\chocolatey\bin\nasm.exe" (
            set "NASM_PREFIX=%ProgramData%\chocolatey\bin\"
            set "PATH=%ProgramData%\chocolatey\bin;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\tools\nasm\nasm.exe" (
            set "NASM_PREFIX=C:\tools\nasm\"
            set "PATH=C:\tools\nasm;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\Program Files\NASM\nasm.exe" (
            set "NASM_PREFIX=C:\Program Files\NASM\"
            set "PATH=C:\Program Files\NASM;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else (
            set "NASM_PREFIX=C:\tools\nasm\"
            echo Set default NASM_PREFIX=%NASM_PREFIX%
          )
        ) else (
          for /f "tokens=*" %%i in ('where nasm') do (
            set "NASM_PATH=%%i"
            goto :found_nasm2
          )
          :found_nasm2
          for %%i in ("%NASM_PATH%") do set "NASM_PREFIX=%%~dpi"
          echo Re-set NASM_PREFIX=%NASM_PREFIX%
        )
        
        REM Re-set CLANG_BIN
        if exist "C:\Program Files\LLVM\bin\clang.exe" (
          set "CLANG_BIN=C:\Program Files\LLVM\bin\"
          echo Re-set CLANG_BIN=%CLANG_BIN%
        )
        
        REM Re-set CYGWIN_HOME to empty to suppress warning
        set "CYGWIN_HOME="
        echo Set CYGWIN_HOME to empty to suppress warning
        
        REM Call edksetup.bat again after BaseTools build to refresh environment
        echo Refreshing EDK2 environment after BaseTools build...
        call edksetup.bat
        
        REM Verify BASE_TOOLS_PATH is still set after refresh
        echo Verifying BASE_TOOLS_PATH after refresh...
        if "%BASE_TOOLS_PATH%"=="" (
          echo WARNING: BASE_TOOLS_PATH lost after refresh, setting manually...
          set "BASE_TOOLS_PATH=%WORKSPACE%\BaseTools"
          echo Set BASE_TOOLS_PATH to: %BASE_TOOLS_PATH%
        ) else (
          echo BASE_TOOLS_PATH confirmed: %BASE_TOOLS_PATH%
        )
        
        REM Verify EDK_TOOLS_BIN is set correctly after edksetup
        echo Verifying EDK_TOOLS_BIN environment variable...
        if "%EDK_TOOLS_BIN%"=="" (
          echo EDK_TOOLS_BIN not set by edksetup, setting manually...
          set "EDK_TOOLS_BIN=%WORKSPACE%\BaseTools\Bin\Win32"
          echo Set EDK_TOOLS_BIN to: %EDK_TOOLS_BIN%
        ) else (
          echo EDK_TOOLS_BIN is: %EDK_TOOLS_BIN%
        )
        
        REM Verify the path exists
        if not exist "%EDK_TOOLS_BIN%" (
          echo WARNING: EDK_TOOLS_BIN path does not exist: %EDK_TOOLS_BIN%
          echo Attempting to find correct BaseTools path...
          
          if exist "%WORKSPACE%\BaseTools\Bin\Win32" (
            set "EDK_TOOLS_BIN=%WORKSPACE%\BaseTools\Bin\Win32"
            echo Corrected EDK_TOOLS_BIN to: %EDK_TOOLS_BIN%
          ) else (
            echo ERROR: Cannot find BaseTools directory
            echo WORKSPACE is: %WORKSPACE%
            dir "%WORKSPACE%\BaseTools" 2>nul || echo BaseTools directory not found
            exit /b 1
          )
        ) else (
          echo ✅ EDK_TOOLS_BIN path verified: %EDK_TOOLS_BIN%
        )
        
        REM Reset CL for application build (we want warnings for our code)
        set CL=
        
        REM Build ACPIPatcher with custom debug level
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t VS2022 ^
              -p ACPIPatcherPkg\ACPIPatcherPkg.dsc ^
              -D DEBUG_LEVEL=${{ env.DEBUG_LEVEL }}
    
    - name: Verify Build Output
      shell: powershell
      run: |
        cd edk2
        $BUILD_DIR = "Build\ACPIPatcherPkg\${{ matrix.build_type }}_VS2022\${{ matrix.arch }}"
        
        Write-Host "Build directory contents:"
        Get-ChildItem "$BUILD_DIR" -ErrorAction SilentlyContinue | Format-Table
        
        # Check if binaries exist
        if (Test-Path "$BUILD_DIR\ACPIPatcher.efi") {
          Write-Host "✅ ACPIPatcher.efi built successfully"
          Get-ItemProperty "$BUILD_DIR\ACPIPatcher.efi" | Select-Object Name, Length, LastWriteTime
        } else {
          Write-Host "❌ ACPIPatcher.efi not found"
          exit 1
        }
        
        if (Test-Path "$BUILD_DIR\ACPIPatcherDxe.efi") {
          Write-Host "✅ ACPIPatcherDxe.efi built successfully" 
          Get-ItemProperty "$BUILD_DIR\ACPIPatcherDxe.efi" | Select-Object Name, Length, LastWriteTime
        } else {
          Write-Host "❌ ACPIPatcherDxe.efi not found"
          exit 1
        }
    
    - name: Create Distribution Package
      shell: powershell
      run: |
        cd edk2
        $BUILD_DIR = "Build\ACPIPatcherPkg\${{ matrix.build_type }}_VS2022\${{ matrix.arch }}"
        $DIST_DIR = "ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-windows"
        
        New-Item -ItemType Directory -Path "$DIST_DIR" -Force
        Copy-Item "$BUILD_DIR\ACPIPatcher.efi" "$DIST_DIR\"
        Copy-Item "$BUILD_DIR\ACPIPatcherDxe.efi" "$DIST_DIR\"
        if (Test-Path "acpipatcher\Build\ACPI") {
          Copy-Item "acpipatcher\Build\ACPI" "$DIST_DIR\" -Recurse
        }
        Copy-Item "acpipatcher\README.md" "$DIST_DIR\"
        if (Test-Path "acpipatcher\DEBUG_GUIDE.md") {
          Copy-Item "acpipatcher\DEBUG_GUIDE.md" "$DIST_DIR\"
        }
        if (Test-Path "acpipatcher\IMPROVEMENTS.md") {
          Copy-Item "acpipatcher\IMPROVEMENTS.md" "$DIST_DIR\"
        }
        
        # Create version info
        $version = git -C acpipatcher describe --tags --always
        $commit = git -C acpipatcher rev-parse HEAD
        $buildDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
        
        $buildInfo = "ACPIPatcher Build Information`n"
        $buildInfo += "============================`n"
        $buildInfo += "Version: $version`n"
        $buildInfo += "Commit: $commit`n"
        $buildInfo += "Build Date: $buildDate`n"
        $buildInfo += "Architecture: ${{ matrix.arch }}`n"
        $buildInfo += "Build Type: ${{ matrix.build_type }}`n"
        $buildInfo += "Debug Level: ${{ env.DEBUG_LEVEL }}`n"
        $buildInfo += "Toolchain: VS2022`n"
        $buildInfo += "Platform: Windows`n"
        
        $buildInfo | Out-File -FilePath "$DIST_DIR\BUILD_INFO.txt" -Encoding UTF8
        
        Compress-Archive -Path "$DIST_DIR" -DestinationPath "$DIST_DIR.zip"
    
    - name: Validate Build Artifacts
      shell: powershell
      run: |
        cd edk2
        $BUILD_DIR = "Build\ACPIPatcherPkg\${{ matrix.build_type }}_VS2022\${{ matrix.arch }}"
        
        Write-Host "Running build artifact validation..."
        
        # Check if required EFI files exist and have reasonable sizes
        $requiredFiles = @("ACPIPatcher.efi", "ACPIPatcherDxe.efi")
        $allValid = $true
        
        foreach ($file in $requiredFiles) {
          $filePath = Join-Path $BUILD_DIR $file
          if (Test-Path $filePath) {
            $fileInfo = Get-ItemProperty $filePath
            $fileSize = $fileInfo.Length
            
            if ($fileSize -gt 1024 -and $fileSize -lt 10485760) {  # Between 1KB and 10MB
              Write-Host "✅ Valid EFI file: $file ($fileSize bytes)"
            } else {
              Write-Host "❌ Invalid EFI file size: $file ($fileSize bytes)"
              $allValid = $false
            }
          } else {
            Write-Host "❌ Missing EFI file: $file"
            $allValid = $false
          }
        }
        
        if (-not $allValid) {
          Write-Host "❌ Build artifact validation failed"
          exit 1
        }
        
        Write-Host "✅ Build artifact validation passed"
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-windows
        path: edk2/ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-windows.zip
        retention-days: 30

  test-static-analysis:
    name: Static Code Analysis
    runs-on: ubuntu-latest
    needs: [build-linux]
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Install Analysis Tools
      run: |
        sudo apt-get update
        sudo apt-get install -y cppcheck clang-tidy
    
    - name: Run CPPCheck
      run: |
        echo "Running CPPCheck static analysis..."
        cppcheck --enable=all --inconclusive --xml --xml-version=2 \
                 --suppress=missingIncludeSystem \
                 --suppress=unusedFunction \
                 ACPIPatcherPkg/ACPIPatcher/ 2> cppcheck-results.xml || true
        
        # Convert to human readable format
        if [ -s cppcheck-results.xml ]; then
          echo "CPPCheck found issues:"
          cat cppcheck-results.xml
        else
          echo "✅ CPPCheck analysis passed"
        fi
    
    - name: Check Code Style
      run: |
        echo "Checking code formatting..."
        
        # Check for consistent indentation (spaces vs tabs)
        if grep -r $'\t' ACPIPatcherPkg/ACPIPatcher/ --include="*.c" --include="*.h"; then
          echo "⚠️  Warning: Found tab characters, consider using spaces"
        else
          echo "✅ Indentation check passed"
        fi
        
        # Check for trailing whitespace
        if grep -r ' $' ACPIPatcherPkg/ACPIPatcher/ --include="*.c" --include="*.h"; then
          echo "⚠️  Warning: Found trailing whitespace"
        else
          echo "✅ Trailing whitespace check passed"
        fi
    
    - name: Upload Analysis Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: static-analysis-results
        path: cppcheck-results.xml
        retention-days: 7

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [build-linux, build-macos, build-windows, test-static-analysis]
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Download All Artifacts
      uses: actions/download-artifact@v3
      with:
        path: artifacts
    
    - name: Prepare Release Assets
      run: |
        mkdir release-assets
        
        # Copy all build artifacts to release directory
        find artifacts -name "*.tar.gz" -o -name "*.zip" | while read file; do
          cp "$file" release-assets/
        done
        
        # Create a combined release package
        mkdir ACPIPatcher-All-Platforms
        
        # Extract all builds to combined package
        cd release-assets
        for archive in *.tar.gz *.zip; do
          if [[ $archive == *.tar.gz ]]; then
            tar -xzf "$archive"
          else
            unzip -q "$archive"
          fi
        done
        cd ..
        
        # Copy documentation
        cp README.md ACPIPatcher-All-Platforms/ || true
        cp DEBUG_GUIDE.md ACPIPatcher-All-Platforms/ || true
        cp IMPROVEMENTS.md ACPIPatcher-All-Platforms/ || true
        cp LICENSE ACPIPatcher-All-Platforms/ || true
        
        # Create the combined archive
        tar -czf release-assets/ACPIPatcher-All-Platforms.tar.gz ACPIPatcher-All-Platforms
    
    - name: Generate Release Notes
      id: release_notes
      run: |
        echo "## ACPIPatcher Release ${GITHUB_REF#refs/tags/}" > release_notes.md
        echo "" >> release_notes.md
        echo "### Build Information" >> release_notes.md
        echo "- **Build Date:** $(date -u)" >> release_notes.md
        echo "- **Commit:** ${GITHUB_SHA:0:8}" >> release_notes.md
        echo "- **EDK II Version:** ${{ env.EDK2_VERSION }}" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Supported Platforms" >> release_notes.md
        echo "- ✅ **Linux (Ubuntu)** - GCC5 toolchain" >> release_notes.md
        echo "- ✅ **macOS** - Xcode5 toolchain" >> release_notes.md
        echo "- ✅ **Windows** - VS2022 toolchain" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Available Architectures" >> release_notes.md
        echo "- **X64** - 64-bit Intel/AMD (Primary)" >> release_notes.md
        echo "- **IA32** - 32-bit Intel/AMD (Legacy)" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Package Contents" >> release_notes.md
        echo "- \`ACPIPatcher.efi\` - Application version" >> release_notes.md
        echo "- \`ACPIPatcherDxe.efi\` - Driver version" >> release_notes.md
        echo "- \`ACPI/\` - Sample ACPI tables" >> release_notes.md
        echo "- Documentation files" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Installation" >> release_notes.md
        echo "1. Download the appropriate package for your platform" >> release_notes.md
        echo "2. Extract the archive" >> release_notes.md
        echo "3. Follow the instructions in README.md" >> release_notes.md
        echo "" >> release_notes.md
        echo "For detailed usage instructions, see the [README](README.md) and [Debug Guide](DEBUG_GUIDE.md)." >> release_notes.md
    
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        name: ACPIPatcher ${{ github.ref_name }}
        body_path: release_notes.md
        files: release-assets/*
        draft: false
        prerelease: ${{ contains(github.ref_name, 'rc') || contains(github.ref_name, 'beta') || contains(github.ref_name, 'alpha') }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notification:
    name: Build Notification
    runs-on: ubuntu-latest
    needs: [build-linux, build-macos, build-windows, test-static-analysis]
    if: always()
    
    steps:
    - name: Determine Status
      id: status
      run: |
        if [[ "${{ needs.build-linux.result }}" == "success" && 
              "${{ needs.build-macos.result }}" == "success" && 
              "${{ needs.build-windows.result }}" == "success" ]]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "message=✅ All builds completed successfully" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=❌ One or more builds failed" >> $GITHUB_OUTPUT
        fi
    
    - name: Build Summary
      run: |
        echo "## Build Results Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Platform | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|---------|" >> $GITHUB_STEP_SUMMARY
        echo "| Linux (Ubuntu) | ${{ needs.build-linux.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| macOS | ${{ needs.build-macos.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Windows | ${{ needs.build-windows.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Static Analysis | ${{ needs.test-static-analysis.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Overall Status:** ${{ steps.status.outputs.message }}" >> $GITHUB_STEP_SUMMARY
