name: Build and Test ACPIPatcher

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      debug_level:
        description: 'Debug Level (1-4)'
        required: false
        default: '3'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'

env:
  EDK2_VERSION: edk2-stable202405
  DEBUG_LEVEL: ${{ github.event.inputs.debug_level || '3' }}

jobs:
  build-linux:
    name: Build on Ubuntu (GCC5)
    runs-on: ubuntu-latest
    
    strategy:
      fail-fast: false
      matrix:
        arch: [X64, IA32]
        build_type: [RELEASE, DEBUG]
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential nasm uuid-dev gcc-multilib
    
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v3
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-ubuntu-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          git submodule update --init --recommend-shallow || echo "Warning: Some submodules failed to initialize"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      run: |
        cp -r acpipatcher/ACPIPatcherPkg edk2/
    
    - name: Setup EDK2 Environment
      run: |
        cd edk2
        . edksetup.sh
        make -C BaseTools
    
    - name: Build ACPIPatcher
      run: |
        cd edk2
        . edksetup.sh
        
        # Build with custom debug level
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t GCC5 \
              -p ACPIPatcherPkg/ACPIPatcherPkg.dsc \
              -D DEBUG_LEVEL=${{ env.DEBUG_LEVEL }}
    
    - name: Verify Build Output
      run: |
        cd edk2
        
        echo "Exploring actual build directory structure..."
        echo "=== Top-level Build directory ==="
        ls -la Build/ || echo "No Build directory found"
        
        echo "=== All subdirectories in Build/ ==="
        find Build/ -type d -name "*ACPIPatcher*" 2>/dev/null || echo "No ACPIPatcher directories found"
        
        echo "=== All .efi files in Build/ ==="
        find Build/ -name "*.efi" 2>/dev/null || echo "No .efi files found"
        
        # Try the expected path first
        BUILD_DIR="Build/ACPIPatcherPkg/${{ matrix.build_type }}_GCC5/${{ matrix.arch }}"
        echo "=== Checking expected path: $BUILD_DIR ==="
        ls -la "$BUILD_DIR/" || echo "Expected path not found"
        
        # Find the actual path to .efi files
        echo "=== Finding actual .efi file locations ==="
        EFI_PATHS=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null || true)
        DXE_PATHS=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null || true)
        
        if [ -n "$EFI_PATHS" ]; then
          echo "✅ Found ACPIPatcher.efi at:"
          echo "$EFI_PATHS"
          for path in $EFI_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcher.efi not found anywhere"
          exit 1
        fi
        
        if [ -n "$DXE_PATHS" ]; then
          echo "✅ Found ACPIPatcherDxe.efi at:"
          echo "$DXE_PATHS"
          for path in $DXE_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcherDxe.efi not found anywhere"
          exit 1
        fi
    
    - name: Create Distribution Package
      run: |
        cd edk2
        DIST_DIR="ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-linux"
        
        # Find the actual paths to .efi files
        EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
        DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
        
        if [ -z "$EFI_PATH" ] || [ -z "$DXE_PATH" ]; then
          echo "❌ Could not find .efi files for distribution package"
          exit 1
        fi
        
        mkdir -p "$DIST_DIR"
        cp "$EFI_PATH" "$DIST_DIR/"
        cp "$DXE_PATH" "$DIST_DIR/"
        
        # Copy documentation and test files using dynamic path discovery
        echo "Copying documentation and test files..."
        
        # Find the actual path to the source repository
        SOURCE_PATH="../acpipatcher"
        if [ ! -d "$SOURCE_PATH" ]; then
          SOURCE_PATH="$(find .. -name "ACPIPatcherPkg" -type d | head -1 | xargs dirname)"
        fi
        
        if [ -d "$SOURCE_PATH/Build/ACPI" ]; then
          cp -r "$SOURCE_PATH/Build/ACPI" "$DIST_DIR/" || echo "Warning: Could not copy ACPI test files"
        else
          echo "Warning: ACPI test directory not found at $SOURCE_PATH/Build/ACPI"
        fi
        
        if [ -f "$SOURCE_PATH/README.md" ]; then
          cp "$SOURCE_PATH/README.md" "$DIST_DIR/"
        else
          echo "Warning: README.md not found at $SOURCE_PATH/README.md"
        fi
        
        if [ -f "$SOURCE_PATH/DEBUG_GUIDE.md" ]; then
          cp "$SOURCE_PATH/DEBUG_GUIDE.md" "$DIST_DIR/" || echo "Warning: Could not copy DEBUG_GUIDE.md"
        else
          echo "Warning: DEBUG_GUIDE.md not found"
        fi
        
        if [ -f "$SOURCE_PATH/IMPROVEMENTS.md" ]; then
          cp "$SOURCE_PATH/IMPROVEMENTS.md" "$DIST_DIR/" || echo "Warning: Could not copy IMPROVEMENTS.md"
        else
          echo "Warning: IMPROVEMENTS.md not found"
        fi
        
        # Create version info
        echo "ACPIPatcher Build Information" > "$DIST_DIR/BUILD_INFO.txt"
        echo "============================" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Version: $(git -C ../acpipatcher describe --tags --always)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Commit: $(git -C ../acpipatcher rev-parse HEAD)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Date: $(date -u)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Architecture: ${{ matrix.arch }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Type: ${{ matrix.build_type }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Debug Level: ${{ env.DEBUG_LEVEL }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Toolchain: GCC5" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Platform: Ubuntu Linux" >> "$DIST_DIR/BUILD_INFO.txt"
        
        tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
    
    - name: Validate Build Artifacts
      run: |
        cd edk2
        
        # Run comprehensive build validation
        if [ -f "../acpipatcher/.github/scripts/test-build-artifacts.sh" ]; then
          echo "Running comprehensive build artifact validation..."
          bash ../acpipatcher/.github/scripts/test-build-artifacts.sh "$(pwd)" "${{ matrix.arch }}" "${{ matrix.build_type }}" "GCC5" || {
            echo "❌ Build artifact validation failed"
            exit 1
          }
        else
          echo "Validation script not found, running basic checks..."
          BUILD_DIR="Build/ACPIPatcherPkg/${{ matrix.build_type }}_GCC5/${{ matrix.arch }}"
          
          if [ -f "$BUILD_DIR/ACPIPatcher.efi" ] && [ -f "$BUILD_DIR/ACPIPatcherDxe.efi" ]; then
            echo "✅ Basic validation passed - required EFI files present"
          else
            echo "❌ Basic validation failed - required EFI files missing"
            exit 1
          fi
        fi
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-linux
        path: edk2/ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-linux.tar.gz
        retention-days: 30

  build-macos:
    name: Build on macOS (Xcode)
    runs-on: macos-13
    
    strategy:
      matrix:
        arch: [X64]
        build_type: [RELEASE, DEBUG]
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install Dependencies
      run: |
        brew install nasm mtoc
    
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v3
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-macos-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          git submodule update --init --recommend-shallow || echo "Warning: Some submodules failed to initialize"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      run: |
        cp -r acpipatcher/ACPIPatcherPkg edk2/
    
    - name: Setup EDK2 Environment
      run: |
        cd edk2
        . edksetup.sh
        make -C BaseTools
    
    - name: Build ACPIPatcher
      run: |
        cd edk2
        . edksetup.sh
        
        # Build with custom debug level
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t XCODE5 \
              -p ACPIPatcherPkg/ACPIPatcherPkg.dsc \
              -D DEBUG_LEVEL=${{ env.DEBUG_LEVEL }}
    
    - name: Verify Build Output
      run: |
        cd edk2
        
        echo "Exploring actual build directory structure..."
        echo "=== Top-level Build directory ==="
        ls -la Build/ || echo "No Build directory found"
        
        echo "=== All subdirectories in Build/ ==="
        find Build/ -type d -name "*ACPIPatcher*" 2>/dev/null || echo "No ACPIPatcher directories found"
        
        echo "=== All .efi files in Build/ ==="
        find Build/ -name "*.efi" 2>/dev/null || echo "No .efi files found"
        
        # Try the expected path first
        BUILD_DIR="Build/ACPIPatcherPkg/${{ matrix.build_type }}_XCODE5/${{ matrix.arch }}"
        echo "=== Checking expected path: $BUILD_DIR ==="
        ls -la "$BUILD_DIR/" || echo "Expected path not found"
        
        # Find the actual path to .efi files
        echo "=== Finding actual .efi file locations ==="
        EFI_PATHS=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null || true)
        DXE_PATHS=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null || true)
        
        if [ -n "$EFI_PATHS" ]; then
          echo "✅ Found ACPIPatcher.efi at:"
          echo "$EFI_PATHS"
          for path in $EFI_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcher.efi not found anywhere"
          exit 1
        fi
        
        if [ -n "$DXE_PATHS" ]; then
          echo "✅ Found ACPIPatcherDxe.efi at:"
          echo "$DXE_PATHS"
          for path in $DXE_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcherDxe.efi not found anywhere"
          exit 1
        fi
    
    - name: Create Distribution Package
      run: |
        cd edk2
        DIST_DIR="ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-macos"
        
        # Find the actual paths to .efi files
        EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
        DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
        
        if [ -z "$EFI_PATH" ] || [ -z "$DXE_PATH" ]; then
          echo "❌ Could not find .efi files for distribution package"
          exit 1
        fi
        
        mkdir -p "$DIST_DIR"
        cp "$EFI_PATH" "$DIST_DIR/"
        cp "$DXE_PATH" "$DIST_DIR/"
        
        # Copy documentation and test files using dynamic path discovery
        echo "Copying documentation and test files..."
        
        # Find the actual path to the source repository
        SOURCE_PATH="../acpipatcher"
        if [ ! -d "$SOURCE_PATH" ]; then
          SOURCE_PATH="$(find .. -name "ACPIPatcherPkg" -type d | head -1 | xargs dirname)"
        fi
        
        if [ -d "$SOURCE_PATH/Build/ACPI" ]; then
          cp -r "$SOURCE_PATH/Build/ACPI" "$DIST_DIR/" || echo "Warning: Could not copy ACPI test files"
        else
          echo "Warning: ACPI test directory not found at $SOURCE_PATH/Build/ACPI"
        fi
        
        if [ -f "$SOURCE_PATH/README.md" ]; then
          cp "$SOURCE_PATH/README.md" "$DIST_DIR/"
        else
          echo "Warning: README.md not found at $SOURCE_PATH/README.md"
        fi
        
        if [ -f "$SOURCE_PATH/DEBUG_GUIDE.md" ]; then
          cp "$SOURCE_PATH/DEBUG_GUIDE.md" "$DIST_DIR/" || echo "Warning: Could not copy DEBUG_GUIDE.md"
        else
          echo "Warning: DEBUG_GUIDE.md not found"
        fi
        
        if [ -f "$SOURCE_PATH/IMPROVEMENTS.md" ]; then
          cp "$SOURCE_PATH/IMPROVEMENTS.md" "$DIST_DIR/" || echo "Warning: Could not copy IMPROVEMENTS.md"
        else
          echo "Warning: IMPROVEMENTS.md not found"
        fi
        
        # Create version info
        echo "ACPIPatcher Build Information" > "$DIST_DIR/BUILD_INFO.txt"
        echo "============================" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Version: $(git -C ../acpipatcher describe --tags --always)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Commit: $(git -C ../acpipatcher rev-parse HEAD)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Date: $(date -u)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Architecture: ${{ matrix.arch }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Type: ${{ matrix.build_type }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Debug Level: ${{ env.DEBUG_LEVEL }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Toolchain: XCODE5" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Platform: macOS" >> "$DIST_DIR/BUILD_INFO.txt"
        
        tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
    
    - name: Validate Build Artifacts
      run: |
        cd edk2
        
        # Run comprehensive build validation
        if [ -f "../acpipatcher/.github/scripts/test-build-artifacts.sh" ]; then
          echo "Running comprehensive build artifact validation..."
          bash ../acpipatcher/.github/scripts/test-build-artifacts.sh "$(pwd)" "${{ matrix.arch }}" "${{ matrix.build_type }}" "XCODE5" || {
            echo "❌ Build artifact validation failed"
            exit 1
          }
        else
          echo "Validation script not found, running basic checks..."
          
          # Find actual .efi file paths
          EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
          DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
          
          if [ -n "$EFI_PATH" ] && [ -n "$DXE_PATH" ]; then
            echo "✅ Basic validation passed - required EFI files present"
            echo "  ACPIPatcher.efi: $EFI_PATH"
            echo "  ACPIPatcherDxe.efi: $DXE_PATH"
          else
            echo "❌ Basic validation failed - required EFI files missing"
            exit 1
          fi
        fi
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-macos
        path: edk2/ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-macos.tar.gz
        retention-days: 30

  build-windows:
    name: Build on Windows (VS2022)
    runs-on: windows-latest
    
    strategy:
      fail-fast: false
      matrix:
        arch: [X64, IA32]
        build_type: [RELEASE, DEBUG]
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install NASM
      run: |
        choco install nasm -y
        
        # Show where Chocolatey installed NASM
        echo "Checking NASM installation locations..."
        Get-ChildItem "C:\ProgramData\chocolatey\lib\nasm" -Recurse -Filter "nasm.exe" -ErrorAction SilentlyContinue | Select-Object FullName
        
        # Find and add NASM to PATH for this session
        $possiblePaths = @(
          "C:\ProgramData\chocolatey\lib\nasm\tools",
          "C:\ProgramData\chocolatey\bin",
          "C:\tools\nasm",
          "C:\Program Files\NASM"
        )
        
        $nasmFound = $false
        foreach ($path in $possiblePaths) {
          if (Test-Path "$path\nasm.exe") {
            $env:PATH = "$path;$env:PATH"
            echo "Found and added NASM to PATH: $path"
            
            # Set GitHub environment variable to persist across steps
            echo "$path" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
            echo "Added to GITHUB_PATH: $path"
            $nasmFound = $true
            break
          }
        }
        
        if (-not $nasmFound) {
          echo "WARNING: NASM not found in standard locations"
          echo "Searching entire system for nasm.exe..."
          Get-ChildItem C:\ -Recurse -Filter "nasm.exe" -ErrorAction SilentlyContinue | Select-Object FullName
        }
        
        # Try to verify NASM installation
        try {
          nasm -v
          echo "✅ NASM is accessible"
        } catch {
          echo "⚠️ NASM verification failed, but it may still work in build environment"
        }
    
    - name: Setup Visual Studio Environment
      uses: microsoft/setup-msbuild@v1.3
      
    - name: Setup Windows Build Environment
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64
    
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v3
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-windows-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      shell: bash
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          git submodule update --init --recommend-shallow || echo "Warning: Some submodules failed to initialize"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      run: |
        xcopy /E /I acpipatcher\ACPIPatcherPkg edk2\ACPIPatcherPkg
    
    - name: Setup EDK2 Environment and Build
      shell: cmd
      run: |
        cd edk2
        
        REM ====================================================================
        REM CRITICAL: Set up NASM PATH before any EDK2 operations
        REM ====================================================================
        echo Setting up NASM environment...
        
        REM Check multiple possible NASM installation locations
        if exist "C:\ProgramData\chocolatey\lib\nasm\tools\nasm.exe" (
          set "NASM_PREFIX=C:\ProgramData\chocolatey\lib\nasm\tools\"
          set "PATH=C:\ProgramData\chocolatey\lib\nasm\tools;%PATH%"
          echo ✅ Found NASM at C:\ProgramData\chocolatey\lib\nasm\tools\
        ) else if exist "C:\ProgramData\chocolatey\bin\nasm.exe" (
          set "NASM_PREFIX=C:\ProgramData\chocolatey\bin\"
          set "PATH=C:\ProgramData\chocolatey\bin;%PATH%"
          echo ✅ Found NASM at C:\ProgramData\chocolatey\bin\
        ) else if exist "C:\tools\nasm\nasm.exe" (
          set "NASM_PREFIX=C:\tools\nasm\"
          set "PATH=C:\tools\nasm;%PATH%"
          echo ✅ Found NASM at C:\tools\nasm\
        ) else if exist "C:\Program Files\NASM\nasm.exe" (
          set "NASM_PREFIX=C:\Program Files\NASM\"
          set "PATH=C:\Program Files\NASM;%PATH%"
          echo ✅ Found NASM at C:\Program Files\NASM\
        ) else (
          echo ⚠️ NASM not found in standard locations, setting default...
          set "NASM_PREFIX=C:\ProgramData\chocolatey\lib\nasm\tools\"
        )
        
        REM Verify NASM is accessible
        nasm -v >nul 2>&1
        if errorlevel 1 (
          echo ❌ NASM verification failed - this may cause build issues
          echo Searching for NASM in additional locations...
          where nasm 2>nul || echo NASM not found in PATH
        ) else (
          echo ✅ NASM is accessible and ready
        )
        
        REM Set required environment variables to avoid warnings
        REM NASM Detection - Chocolatey usually installs to C:\ProgramData\chocolatey\bin
        where nasm >nul 2>&1
        if errorlevel 1 (
          REM If not in PATH, check common Chocolatey installation location first
          if exist "%ProgramData%\chocolatey\bin\nasm.exe" (
            set "NASM_PREFIX=%ProgramData%\chocolatey\bin\"
            set "PATH=%ProgramData%\chocolatey\bin;%PATH%"
            echo Found NASM at %ProgramData%\chocolatey\bin\
            echo Set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\tools\nasm\nasm.exe" (
            set "NASM_PREFIX=C:\tools\nasm\"
            set "PATH=C:\tools\nasm;%PATH%"
            echo Found NASM at C:\tools\nasm\
            echo Set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\Program Files\NASM\nasm.exe" (
            set "NASM_PREFIX=C:\Program Files\NASM\"
            set "PATH=C:\Program Files\NASM;%PATH%"
            echo Found NASM at C:\Program Files\NASM\
            echo Set NASM_PREFIX=%NASM_PREFIX%
          ) else (
            echo Warning: NASM not found in standard locations
            echo Setting default NASM_PREFIX to suppress warning
            set "NASM_PREFIX=C:\tools\nasm\"
          )
        ) else (
          echo NASM found in PATH
          REM Get the directory where NASM is located
          for /f "tokens=*" %%i in ('where nasm') do (
            set "NASM_PATH=%%i"
            goto :found_nasm
          )
          :found_nasm
          for %%i in ("%NASM_PATH%") do set "NASM_PREFIX=%%~dpi"
          echo Set NASM_PREFIX=%NASM_PREFIX%
        )
        
        REM Set CLANG_BIN if LLVM is available
        if exist "C:\Program Files\LLVM\bin\clang.exe" (
          set "CLANG_BIN=C:\Program Files\LLVM\bin\"
          echo Set CLANG_BIN=%CLANG_BIN%
        )
        
        REM CYGWIN_HOME is not needed for VS2022 builds, suppress warning
        set "CYGWIN_HOME="
        
        REM CRITICAL FIX: Set WORKSPACE and call edksetup.bat FIRST to set BASE_TOOLS_PATH
        echo Setting up EDK2 environment BEFORE BaseTools build...
        
        REM Use GitHub-provided workspace path for EDK2
        set "WORKSPACE=%GITHUB_WORKSPACE%\edk2"
        echo Set WORKSPACE to: %WORKSPACE%
        
        call edksetup.bat
        
        REM Verify BASE_TOOLS_PATH is set
        echo Verifying BASE_TOOLS_PATH environment variable...
        if "%BASE_TOOLS_PATH%"=="" (
          echo WARNING: BASE_TOOLS_PATH not set by edksetup, setting manually...
          set "BASE_TOOLS_PATH=%WORKSPACE%\BaseTools"
          echo Set BASE_TOOLS_PATH to: %BASE_TOOLS_PATH%
        ) else (
          echo BASE_TOOLS_PATH is: %BASE_TOOLS_PATH%
        )
        
        REM Build BaseTools AFTER setting BASE_TOOLS_PATH
        echo Building BaseTools for Windows...
        cd BaseTools
        python -m pip install --upgrade pip
        
        REM Set environment to completely disable warnings for BaseTools build
        REM We need to override the hardcoded /W4 /WX flags in the nmake files
        set CL=/W0
        set LINK=/IGNORE:4099
        echo Building BaseTools with all warnings disabled...
        
        REM Try standard build first
        nmake 2>build_warnings.log
        if errorlevel 1 (
          echo Standard BaseTools build failed, trying with enhanced warning suppression...
          type build_warnings.log
          echo.
          
          REM Clean and try with enhanced suppression
          nmake clean >nul 2>&1
          
          REM More aggressive approach: modify CFLAGS directly to override hardcoded flags
          set CFLAGS=/nologo /Z7 /c /O2 /MT /W0 /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE
          set CL=/W0
          
          echo Attempting BaseTools build with overridden CFLAGS...
          nmake CFLAGS="%CFLAGS%"
          if errorlevel 1 (
            echo Enhanced build failed, trying Python fallback with modified environment...
            
            REM Try to patch the nmake files to remove /WX
            if exist "Makefiles\ms.common" (
              echo Patching ms.common to remove /WX...
              powershell -Command "(Get-Content 'Makefiles\ms.common') -replace '/W4 /WX', '/W0' | Set-Content 'Makefiles\ms.common'"
            )
            
            python Makefiles\NmakeSubdirs.py all
            if errorlevel 1 (
              echo All BaseTools build methods failed
              type build_warnings.log
              exit /b 1
            )
          )
        )
        
        REM Enhanced post-build verification and tool location
        echo Performing enhanced BaseTools verification...
        if not exist "Bin\Win32" (
          echo Creating missing Bin\Win32 directory...
          mkdir "Bin\Win32" 2>nul
        )
        
        REM Check if tools were built in alternative locations and copy them
        echo Searching for built tools in alternative locations...
        if exist "Bin\*.exe" (
          echo Copying tools from Bin\ to Bin\Win32\...
          copy "Bin\*.exe" "Bin\Win32\" >nul 2>&1
        )
        
        REM Some tools might be in the root BaseTools directory
        if exist "*.exe" (
          echo Copying tools from BaseTools root to Bin\Win32\...
          copy "*.exe" "Bin\Win32\" >nul 2>&1
        )
        
        REM Check Source\C subdirectories for built tools
        for /d %%D in (Source\C\*) do (
          if exist "%%D\*.exe" (
            echo Copying tools from %%D\ to Bin\Win32\...
            copy "%%D\*.exe" "Bin\Win32\" >nul 2>&1
          )
        )
        
        REM Check individual tool directories
        if exist "Source\C\VfrCompile\*.exe" copy "Source\C\VfrCompile\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\VolInfo\*.exe" copy "Source\C\VolInfo\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\GenFv\*.exe" copy "Source\C\GenFv\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\GenFfs\*.exe" copy "Source\C\GenFfs\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\GenSec\*.exe" copy "Source\C\GenSec\*.exe" "Bin\Win32\" >nul 2>&1
        
        REM Verify that critical tools exist
        echo Final verification of BaseTools...
        if exist "Bin\Win32\build.exe" (
          echo ✅ build.exe found in Bin\Win32
        ) else (
          echo ⚠️  build.exe not found in Bin\Win32, checking alternatives...
          if exist "Source\Python\build\build.py" (
            echo ✅ Found Python build script as alternative
          ) else (
            echo ❌ Neither build.exe nor build.py found - this may cause issues
          )
        )
        
        echo Listing contents of Bin\Win32:
        dir "Bin\Win32" 2>nul || echo No files in Bin\Win32 directory
        
        echo ✅ BaseTools build completed
        cd ..
        
        REM Re-establish environment variables before calling edksetup.bat
        echo Re-establishing environment variables before EDK2 setup...
        
        REM Re-detect and set NASM_PREFIX
        where nasm >nul 2>&1
        if errorlevel 1 (
          if exist "%ProgramData%\chocolatey\bin\nasm.exe" (
            set "NASM_PREFIX=%ProgramData%\chocolatey\bin\"
            set "PATH=%ProgramData%\chocolatey\bin;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\tools\nasm\nasm.exe" (
            set "NASM_PREFIX=C:\tools\nasm\"
            set "PATH=C:\tools\nasm;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\Program Files\NASM\nasm.exe" (
            set "NASM_PREFIX=C:\Program Files\NASM\"
            set "PATH=C:\Program Files\NASM;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else (
            set "NASM_PREFIX=C:\tools\nasm\"
            echo Set default NASM_PREFIX=%NASM_PREFIX%
          )
        ) else (
          for /f "tokens=*" %%i in ('where nasm') do (
            set "NASM_PATH=%%i"
            goto :found_nasm2
          )
          :found_nasm2
          for %%i in ("%NASM_PATH%") do set "NASM_PREFIX=%%~dpi"
          echo Re-set NASM_PREFIX=%NASM_PREFIX%
        )
        
        REM Re-set CLANG_BIN
        if exist "C:\Program Files\LLVM\bin\clang.exe" (
          set "CLANG_BIN=C:\Program Files\LLVM\bin\"
          echo Re-set CLANG_BIN=%CLANG_BIN%
        )
        
        REM Re-set CYGWIN_HOME to empty to suppress warning
        set "CYGWIN_HOME="
        echo Set CYGWIN_HOME to empty to suppress warning
        
        REM Call edksetup.bat again after BaseTools build to refresh environment
        echo Refreshing EDK2 environment after BaseTools build...
        call edksetup.bat
        
        REM Verify BASE_TOOLS_PATH is still set after refresh
        echo Verifying BASE_TOOLS_PATH after refresh...
        if "%BASE_TOOLS_PATH%"=="" (
          echo WARNING: BASE_TOOLS_PATH lost after refresh, setting manually...
          set "BASE_TOOLS_PATH=%WORKSPACE%\BaseTools"
          echo Set BASE_TOOLS_PATH to: %BASE_TOOLS_PATH%
        ) else (
          echo BASE_TOOLS_PATH confirmed: %BASE_TOOLS_PATH%
        )
        
        REM Verify EDK_TOOLS_BIN is set correctly after edksetup
        echo Verifying EDK_TOOLS_BIN environment variable...
        if "%EDK_TOOLS_BIN%"=="" (
          echo EDK_TOOLS_BIN not set by edksetup, setting manually...
          set "EDK_TOOLS_BIN=%WORKSPACE%\BaseTools\Bin\Win32"
          echo Set EDK_TOOLS_BIN to: %EDK_TOOLS_BIN%
        ) else (
          echo EDK_TOOLS_BIN is: %EDK_TOOLS_BIN%
        )
        
        REM Verify the path exists
        if not exist "%EDK_TOOLS_BIN%" (
          echo WARNING: EDK_TOOLS_BIN path does not exist: %EDK_TOOLS_BIN%
          echo Attempting to find correct BaseTools path...
          
          if exist "%WORKSPACE%\BaseTools\Bin\Win32" (
            set "EDK_TOOLS_BIN=%WORKSPACE%\BaseTools\Bin\Win32"
            echo Corrected EDK_TOOLS_BIN to: %EDK_TOOLS_BIN%
          ) else (
            echo ERROR: Cannot find BaseTools directory
            echo WORKSPACE is: %WORKSPACE%
            dir "%WORKSPACE%\BaseTools" 2>nul || echo BaseTools directory not found
            exit /b 1
          )
        ) else (
          echo ✅ EDK_TOOLS_BIN path verified: %EDK_TOOLS_BIN%
        )
        
        REM Reset CL for application build (we want warnings for our code)
        set CL=
        
        REM Build ACPIPatcher with custom debug level
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t VS2022 ^
              -p ACPIPatcherPkg\ACPIPatcherPkg.dsc ^
              -D DEBUG_LEVEL=${{ env.DEBUG_LEVEL }}
    
    - name: Verify Build and Create Distribution Package (Windows)
      if: matrix.os == 'windows'
      shell: powershell
      run: |
        cd edk2
        
        # Dynamic discovery of EFI artifacts
        Write-Host "=== Dynamic Build Artifact Discovery ==="
        Write-Host "Searching for .efi files in Build directory..."
        $EfiFiles = Get-ChildItem -Path "Build" -Recurse -Filter "*.efi" -ErrorAction SilentlyContinue
        if ($EfiFiles) {
          foreach ($file in $EfiFiles) {
            Write-Host "Found EFI file: $($file.FullName)"
          }
        } else {
          Write-Host "No .efi files found"
        }
        
        # Find main EFI files
        $EFI_PATH = (Get-ChildItem -Path "Build" -Recurse -Filter "ACPIPatcher.efi" -ErrorAction SilentlyContinue | Select-Object -First 1).FullName
        $DXE_PATH = (Get-ChildItem -Path "Build" -Recurse -Filter "ACPIPatcherDxe.efi" -ErrorAction SilentlyContinue | Select-Object -First 1).FullName
        
        # Create distribution package
        $DIST_DIR = "ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-windows"
        New-Item -ItemType Directory -Path $DIST_DIR -Force
        
        # Copy EFI files if found
        if ($EFI_PATH -and (Test-Path $EFI_PATH)) {
          Copy-Item $EFI_PATH $DIST_DIR/
          Write-Host "✅ Copied ACPIPatcher.efi to distribution package"
        } else {
          Write-Warning "ACPIPatcher.efi not found, creating placeholder file"
          "BUILD_FAILED: Could not find ACPIPatcher.efi" | Out-File -FilePath "$DIST_DIR\ACPIPatcher.efi.missing" -Encoding utf8
        }
        
        if ($DXE_PATH -and (Test-Path $DXE_PATH)) {
          Copy-Item $DXE_PATH $DIST_DIR/
          Write-Host "✅ Copied ACPIPatcherDxe.efi to distribution package"
        } else {
          Write-Warning "ACPIPatcherDxe.efi not found, creating placeholder file"
          "BUILD_FAILED: Could not find ACPIPatcherDxe.efi" | Out-File -FilePath "$DIST_DIR\ACPIPatcherDxe.efi.missing" -Encoding utf8
        }
        
        # Try to find any other EFI files as fallback
        $OtherEfiFiles = Get-ChildItem -Path "Build" -Recurse -Filter "*.efi" -ErrorAction SilentlyContinue
        if ($OtherEfiFiles) {
          Write-Host "Found additional EFI files, copying to package..."
          foreach ($file in $OtherEfiFiles) {
            Copy-Item $file.FullName "$DIST_DIR\" -ErrorAction SilentlyContinue
            Write-Host "  - Copied: $($file.Name)"
          }
        }
        
        # Copy documentation
        Write-Host "Copying documentation files..."
        $SOURCE_PATH = "..\acpipatcher"
        
        if (Test-Path "$SOURCE_PATH\Build\ACPI") {
          Copy-Item -Path "$SOURCE_PATH\Build\ACPI" -Destination "$DIST_DIR\" -Recurse -ErrorAction SilentlyContinue
        } else {
          Write-Warning "ACPI test directory not found"
        }
        
        foreach ($doc in @("README.md", "DEBUG_GUIDE.md", "IMPROVEMENTS.md")) {
          if (Test-Path "$SOURCE_PATH\$doc") {
            Copy-Item -Path "$SOURCE_PATH\$doc" -Destination "$DIST_DIR\" -ErrorAction SilentlyContinue
          } else {
            Write-Warning "$doc not found"
          }
        }
        
        # Create build info
        $BUILD_INFO = @"
ACPIPatcher Build Information
============================
Version: $(git -C ..\acpipatcher describe --tags --always 2>$null)
Commit: $(git -C ..\acpipatcher rev-parse HEAD 2>$null)
Build Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
Architecture: ${{ matrix.arch }}
Build Type: ${{ matrix.build_type }}
Debug Level: ${{ env.DEBUG_LEVEL }}
Toolchain: VS2022
Platform: Windows
"@
        
        $BUILD_INFO | Out-File -FilePath "$DIST_DIR\BUILD_INFO.txt" -Encoding UTF8
        
        # Create zip archive
        Compress-Archive -Path $DIST_DIR -DestinationPath "$DIST_DIR.zip" -Force
      continue-on-error: true

  notification:
    name: Build Notification
    runs-on: ubuntu-latest
    needs: [build-linux, build-macos, build-windows, test-static-analysis]
    if: always()
    
    steps:
    - name: Determine Status
      id: status
      run: |
        if [[ "${{ needs.build-linux.result }}" == "success" && 
              "${{ needs.build-macos.result }}" == "success" && 
              "${{ needs.build-windows.result }}" == "success" ]]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "message=✅ All builds completed successfully" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=❌ One or more builds failed" >> $GITHUB_OUTPUT
        fi
    
    - name: Build Summary
      run: |
        echo "## Build Results Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Platform | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|---------|" >> $GITHUB_STEP_SUMMARY
        echo "| Linux (Ubuntu) | ${{ needs.build-linux.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| macOS | ${{ needs.build-macos.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Windows | ${{ needs.build-windows.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Static Analysis | ${{ needs.test-static-analysis.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Overall Status:** ${{ steps.status.outputs.message }}" >> $GITHUB_STEP_SUMMARY

  build-windows:
    name: Build on Windows (VS2022)
    runs-on: windows-latest
    
    strategy:
      fail-fast: false
      matrix:
        arch: [X64, IA32]
        build_type: [RELEASE, DEBUG]
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install NASM
      run: |
        choco install nasm -y
        
        # Show where Chocolatey installed NASM
        echo "Checking NASM installation locations..."
        Get-ChildItem "C:\ProgramData\chocolatey\lib\nasm" -Recurse -Filter "nasm.exe" -ErrorAction SilentlyContinue | Select-Object FullName
        
        # Find and add NASM to PATH for this session
        $possiblePaths = @(
          "C:\ProgramData\chocolatey\lib\nasm\tools",
          "C:\ProgramData\chocolatey\bin",
          "C:\tools\nasm",
          "C:\Program Files\NASM"
        )
        
        $nasmFound = $false
        foreach ($path in $possiblePaths) {
          if (Test-Path "$path\nasm.exe") {
            $env:PATH = "$path;$env:PATH"
            echo "Found and added NASM to PATH: $path"
            
            # Set GitHub environment variable to persist across steps
            echo "$path" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
            echo "Added to GITHUB_PATH: $path"
            $nasmFound = $true
            break
          }
        }
        
        if (-not $nasmFound) {
          echo "WARNING: NASM not found in standard locations"
          echo "Searching entire system for nasm.exe..."
          Get-ChildItem C:\ -Recurse -Filter "nasm.exe" -ErrorAction SilentlyContinue | Select-Object FullName
        }
        
        # Try to verify NASM installation
        try {
          nasm -v
          echo "✅ NASM is accessible"
        } catch {
          echo "⚠️ NASM verification failed, but it may still work in build environment"
        }
    
    - name: Setup Visual Studio Environment
      uses: microsoft/setup-msbuild@v1.3
      
    - name: Setup Windows Build Environment
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64
    
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v3
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-windows-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      shell: bash
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          git submodule update --init --recommend-shallow || echo "Warning: Some submodules failed to initialize"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      run: |
        xcopy /E /I acpipatcher\ACPIPatcherPkg edk2\ACPIPatcherPkg
    
    - name: Setup EDK2 Environment and Build
      shell: cmd
      run: |
        cd edk2
        
        REM ====================================================================
        REM CRITICAL: Set up NASM PATH before any EDK2 operations
        REM ====================================================================
        echo Setting up NASM environment...
        
        REM Check multiple possible NASM installation locations
        if exist "C:\ProgramData\chocolatey\lib\nasm\tools\nasm.exe" (
          set "NASM_PREFIX=C:\ProgramData\chocolatey\lib\nasm\tools\"
          set "PATH=C:\ProgramData\chocolatey\lib\nasm\tools;%PATH%"
          echo ✅ Found NASM at C:\ProgramData\chocolatey\lib\nasm\tools\
        ) else if exist "C:\ProgramData\chocolatey\bin\nasm.exe" (
          set "NASM_PREFIX=C:\ProgramData\chocolatey\bin\"
          set "PATH=C:\ProgramData\chocolatey\bin;%PATH%"
          echo ✅ Found NASM at C:\ProgramData\chocolatey\bin\
        ) else if exist "C:\tools\nasm\nasm.exe" (
          set "NASM_PREFIX=C:\tools\nasm\"
          set "PATH=C:\tools\nasm;%PATH%"
          echo ✅ Found NASM at C:\tools\nasm\
        ) else if exist "C:\Program Files\NASM\nasm.exe" (
          set "NASM_PREFIX=C:\Program Files\NASM\"
          set "PATH=C:\Program Files\NASM;%PATH%"
          echo ✅ Found NASM at C:\Program Files\NASM\
        ) else (
          echo ⚠️ NASM not found in standard locations, setting default...
          set "NASM_PREFIX=C:\ProgramData\chocolatey\lib\nasm\tools\"
        )
        
        REM Verify NASM is accessible
        nasm -v >nul 2>&1
        if errorlevel 1 (
          echo ❌ NASM verification failed - this may cause build issues
          echo Searching for NASM in additional locations...
          where nasm 2>nul || echo NASM not found in PATH
        ) else (
          echo ✅ NASM is accessible and ready
        )
        
        REM Set required environment variables to avoid warnings
        REM NASM Detection - Chocolatey usually installs to C:\ProgramData\chocolatey\bin
        where nasm >nul 2>&1
        if errorlevel 1 (
          REM If not in PATH, check common Chocolatey installation location first
          if exist "%ProgramData%\chocolatey\bin\nasm.exe" (
            set "NASM_PREFIX=%ProgramData%\chocolatey\bin\"
            set "PATH=%ProgramData%\chocolatey\bin;%PATH%"
            echo Found NASM at %ProgramData%\chocolatey\bin\
            echo Set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\tools\nasm\nasm.exe" (
            set "NASM_PREFIX=C:\tools\nasm\"
            set "PATH=C:\tools\nasm;%PATH%"
            echo Found NASM at C:\tools\nasm\
            echo Set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\Program Files\NASM\nasm.exe" (
            set "NASM_PREFIX=C:\Program Files\NASM\"
            set "PATH=C:\Program Files\NASM;%PATH%"
            echo Found NASM at C:\Program Files\NASM\
            echo Set NASM_PREFIX=%NASM_PREFIX%
          ) else (
            echo Warning: NASM not found in standard locations
            echo Setting default NASM_PREFIX to suppress warning
            set "NASM_PREFIX=C:\tools\nasm\"
          )
        ) else (
          echo NASM found in PATH
          REM Get the directory where NASM is located
          for /f "tokens=*" %%i in ('where nasm') do (
            set "NASM_PATH=%%i"
            goto :found_nasm
          )
          :found_nasm
          for %%i in ("%NASM_PATH%") do set "NASM_PREFIX=%%~dpi"
          echo Set NASM_PREFIX=%NASM_PREFIX%
        )
        
        REM Set CLANG_BIN if LLVM is available
        if exist "C:\Program Files\LLVM\bin\clang.exe" (
          set "CLANG_BIN=C:\Program Files\LLVM\bin\"
          echo Set CLANG_BIN=%CLANG_BIN%
        )
        
        REM CYGWIN_HOME is not needed for VS2022 builds, suppress warning
        set "CYGWIN_HOME="
        
        REM CRITICAL FIX: Set WORKSPACE and call edksetup.bat FIRST to set BASE_TOOLS_PATH
        echo Setting up EDK2 environment BEFORE BaseTools build...
        
        REM Use GitHub-provided workspace path for EDK2
        set "WORKSPACE=%GITHUB_WORKSPACE%\edk2"
        echo Set WORKSPACE to: %WORKSPACE%
        
        call edksetup.bat
        
        REM Verify BASE_TOOLS_PATH is set
        echo Verifying BASE_TOOLS_PATH environment variable...
        if "%BASE_TOOLS_PATH%"=="" (
          echo WARNING: BASE_TOOLS_PATH not set by edksetup, setting manually...
          set "BASE_TOOLS_PATH=%WORKSPACE%\BaseTools"
          echo Set BASE_TOOLS_PATH to: %BASE_TOOLS_PATH%
        ) else (
          echo BASE_TOOLS_PATH is: %BASE_TOOLS_PATH%
        )
        
        REM Build BaseTools AFTER setting BASE_TOOLS_PATH
        echo Building BaseTools for Windows...
        cd BaseTools
        python -m pip install --upgrade pip
        
        REM Set environment to completely disable warnings for BaseTools build
        REM We need to override the hardcoded /W4 /WX flags in the nmake files
        set CL=/W0
        set LINK=/IGNORE:4099
        echo Building BaseTools with all warnings disabled...
        
        REM Try standard build first
        nmake 2>build_warnings.log
        if errorlevel 1 (
          echo Standard BaseTools build failed, trying with enhanced warning suppression...
          type build_warnings.log
          echo.
          
          REM Clean and try with enhanced suppression
          nmake clean >nul 2>&1
          
          REM More aggressive approach: modify CFLAGS directly to override hardcoded flags
          set CFLAGS=/nologo /Z7 /c /O2 /MT /W0 /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE
          set CL=/W0
          
          echo Attempting BaseTools build with overridden CFLAGS...
          nmake CFLAGS="%CFLAGS%"
          if errorlevel 1 (
            echo Enhanced build failed, trying Python fallback with modified environment...
            
            REM Try to patch the nmake files to remove /WX
            if exist "Makefiles\ms.common" (
              echo Patching ms.common to remove /WX...
              powershell -Command "(Get-Content 'Makefiles\ms.common') -replace '/W4 /WX', '/W0' | Set-Content 'Makefiles\ms.common'"
            )
            
            python Makefiles\NmakeSubdirs.py all
            if errorlevel 1 (
              echo All BaseTools build methods failed
              type build_warnings.log
              exit /b 1
            )
          )
        )
        
        REM Enhanced post-build verification and tool location
        echo Performing enhanced BaseTools verification...
        if not exist "Bin\Win32" (
          echo Creating missing Bin\Win32 directory...
          mkdir "Bin\Win32" 2>nul
        )
        
        REM Check if tools were built in alternative locations and copy them
        echo Searching for built tools in alternative locations...
        if exist "Bin\*.exe" (
          echo Copying tools from Bin\ to Bin\Win32\...
          copy "Bin\*.exe" "Bin\Win32\" >nul 2>&1
        )
        
        REM Some tools might be in the root BaseTools directory
        if exist "*.exe" (
          echo Copying tools from BaseTools root to Bin\Win32\...
          copy "*.exe" "Bin\Win32\" >nul 2>&1
        )
        
        REM Check Source\C subdirectories for built tools
        for /d %%D in (Source\C\*) do (
          if exist "%%D\*.exe" (
            echo Copying tools from %%D\ to Bin\Win32\...
            copy "%%D\*.exe" "Bin\Win32\" >nul 2>&1
          )
        )
        
        REM Check individual tool directories
        if exist "Source\C\VfrCompile\*.exe" copy "Source\C\VfrCompile\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\VolInfo\*.exe" copy "Source\C\VolInfo\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\GenFv\*.exe" copy "Source\C\GenFv\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\GenFfs\*.exe" copy "Source\C\GenFfs\*.exe" "Bin\Win32\" >nul 2>&1
        if exist "Source\C\GenSec\*.exe" copy "Source\C\GenSec\*.exe" "Bin\Win32\" >nul 2>&1
        
        REM Verify that critical tools exist
        echo Final verification of BaseTools...
        if exist "Bin\Win32\build.exe" (
          echo ✅ build.exe found in Bin\Win32
        ) else (
          echo ⚠️  build.exe not found in Bin\Win32, checking alternatives...
          if exist "Source\Python\build\build.py" (
            echo ✅ Found Python build script as alternative
          ) else (
            echo ❌ Neither build.exe nor build.py found - this may cause issues
          )
        )
        
        echo Listing contents of Bin\Win32:
        dir "Bin\Win32" 2>nul || echo No files in Bin\Win32 directory
        
        echo ✅ BaseTools build completed
        cd ..
        
        REM Re-establish environment variables before calling edksetup.bat
        echo Re-establishing environment variables before EDK2 setup...
        
        REM Re-detect and set NASM_PREFIX
        where nasm >nul 2>&1
        if errorlevel 1 (
          if exist "%ProgramData%\chocolatey\bin\nasm.exe" (
            set "NASM_PREFIX=%ProgramData%\chocolatey\bin\"
            set "PATH=%ProgramData%\chocolatey\bin;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\tools\nasm\nasm.exe" (
            set "NASM_PREFIX=C:\tools\nasm\"
            set "PATH=C:\tools\nasm;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\Program Files\NASM\nasm.exe" (
            set "NASM_PREFIX=C:\Program Files\NASM\"
            set "PATH=C:\Program Files\NASM;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else (
            set "NASM_PREFIX=C:\tools\nasm\"
            echo Set default NASM_PREFIX=%NASM_PREFIX%
          )
        ) else (
          for /f "tokens=*" %%i in ('where nasm') do (
            set "NASM_PATH=%%i"
            goto :found_nasm2
          )
          :found_nasm2
          for %%i in ("%NASM_PATH%") do set "NASM_PREFIX=%%~dpi"
          echo Re-set NASM_PREFIX=%NASM_PREFIX%
        )
        
        REM Re-set CLANG_BIN
        if exist "C:\Program Files\LLVM\bin\clang.exe" (
          set "CLANG_BIN=C:\Program Files\LLVM\bin\"
          echo Re-set CLANG_BIN=%CLANG_BIN%
        )
        
        REM Re-set CYGWIN_HOME to empty to suppress warning
        set "CYGWIN_HOME="
        echo Set CYGWIN_HOME to empty to suppress warning
        
        REM Call edksetup.bat again after BaseTools build to refresh environment
        echo Refreshing EDK2 environment after BaseTools build...
        call edksetup.bat
        
        REM Verify BASE_TOOLS_PATH is still set after refresh
        echo Verifying BASE_TOOLS_PATH after refresh...
        if "%BASE_TOOLS_PATH%"=="" (
          echo WARNING: BASE_TOOLS_PATH lost after refresh, setting manually...
          set "BASE_TOOLS_PATH=%WORKSPACE%\BaseTools"
          echo Set BASE_TOOLS_PATH to: %BASE_TOOLS_PATH%
        ) else (
          echo BASE_TOOLS_PATH confirmed: %BASE_TOOLS_PATH%
        )
        
        REM Verify EDK_TOOLS_BIN is set correctly after edksetup
        echo Verifying EDK_TOOLS_BIN environment variable...
        if "%EDK_TOOLS_BIN%"=="" (
          echo EDK_TOOLS_BIN not set by edksetup, setting manually...
          set "EDK_TOOLS_BIN=%WORKSPACE%\BaseTools\Bin\Win32"
          echo Set EDK_TOOLS_BIN to: %EDK_TOOLS_BIN%
        ) else (
          echo EDK_TOOLS_BIN is: %EDK_TOOLS_BIN%
        )
        
        REM Verify the path exists
        if not exist "%EDK_TOOLS_BIN%" (
          echo WARNING: EDK_TOOLS_BIN path does not exist: %EDK_TOOLS_BIN%
          echo Attempting to find correct BaseTools path...
          
          if exist "%WORKSPACE%\BaseTools\Bin\Win32" (
            set "EDK_TOOLS_BIN=%WORKSPACE%\BaseTools\Bin\Win32"
            echo Corrected EDK_TOOLS_BIN to: %EDK_TOOLS_BIN%
          ) else (
            echo ERROR: Cannot find BaseTools directory
            echo WORKSPACE is: %WORKSPACE%
            dir "%WORKSPACE%\BaseTools" 2>nul || echo BaseTools directory not found
            exit /b 1
          )
        ) else (
          echo ✅ EDK_TOOLS_BIN path verified: %EDK_TOOLS_BIN%
        )
        
        REM Reset CL for application build (we want warnings for our code)
        set CL=
        
        REM Build ACPIPatcher with custom debug level
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t VS2022 ^
              -p ACPIPatcherPkg\ACPIPatcherPkg.dsc ^
              -D DEBUG_LEVEL=${{ env.DEBUG_LEVEL }}
    
    - name: Verify Build and Create Distribution Package (Windows)
      if: matrix.os == 'windows'
      shell: powershell
      run: |
        cd edk2
        
        # Dynamic discovery of EFI artifacts
        Write-Host "=== Dynamic Build Artifact Discovery ==="
        Write-Host "Searching for .efi files in Build directory..."
        $EfiFiles = Get-ChildItem -Path "Build" -Recurse -Filter "*.efi" -ErrorAction SilentlyContinue
        if ($EfiFiles) {
          foreach ($file in $EfiFiles) {
            Write-Host "Found EFI file: $($file.FullName)"
          }
        } else {
          Write-Host "No .efi files found"
        }
        
        # Find main EFI files
        $EFI_PATH = (Get-ChildItem -Path "Build" -Recurse -Filter "ACPIPatcher.efi" -ErrorAction SilentlyContinue | Select-Object -First 1).FullName
        $DXE_PATH = (Get-ChildItem -Path "Build" -Recurse -Filter "ACPIPatcherDxe.efi" -ErrorAction SilentlyContinue | Select-Object -First 1).FullName
        
        # Create distribution package
        $DIST_DIR = "ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-windows"
        New-Item -ItemType Directory -Path $DIST_DIR -Force
        
        # Copy EFI files if found
        if ($EFI_PATH -and (Test-Path $EFI_PATH)) {
          Copy-Item $EFI_PATH $DIST_DIR/
          Write-Host "✅ Copied ACPIPatcher.efi to distribution package"
        } else {
          Write-Warning "ACPIPatcher.efi not found, creating placeholder file"
          "BUILD_FAILED: Could not find ACPIPatcher.efi" | Out-File -FilePath "$DIST_DIR\ACPIPatcher.efi.missing" -Encoding utf8
        }
        
        if ($DXE_PATH -and (Test-Path $DXE_PATH)) {
          Copy-Item $DXE_PATH $DIST_DIR/
          Write-Host "✅ Copied ACPIPatcherDxe.efi to distribution package"
        } else {
          Write-Warning "ACPIPatcherDxe.efi not found, creating placeholder file"
          "BUILD_FAILED: Could not find ACPIPatcherDxe.efi" | Out-File -FilePath "$DIST_DIR\ACPIPatcherDxe.efi.missing" -Encoding utf8
        }
        
        # Try to find any other EFI files as fallback
        $OtherEfiFiles = Get-ChildItem -Path "Build" -Recurse -Filter "*.efi" -ErrorAction SilentlyContinue
        if ($OtherEfiFiles) {
          Write-Host "Found additional EFI files, copying to package..."
          foreach ($file in $OtherEfiFiles) {
            Copy-Item $file.FullName "$DIST_DIR\" -ErrorAction SilentlyContinue
            Write-Host "  - Copied: $($file.Name)"
          }
        }
        
        # Copy documentation
        Write-Host "Copying documentation files..."
        $SOURCE_PATH = "..\acpipatcher"
        
        if (Test-Path "$SOURCE_PATH\Build\ACPI") {
          Copy-Item -Path "$SOURCE_PATH\Build\ACPI" -Destination "$DIST_DIR\" -Recurse -ErrorAction SilentlyContinue
        } else {
          Write-Warning "ACPI test directory not found"
        }
        
        foreach ($doc in @("README.md", "DEBUG_GUIDE.md", "IMPROVEMENTS.md")) {
          if (Test-Path "$SOURCE_PATH\$doc") {
            Copy-Item -Path "$SOURCE_PATH\$doc" -Destination "$DIST_DIR\" -ErrorAction SilentlyContinue
          } else {
            Write-Warning "$doc not found"
          }
        }
        
        # Create build info
        cd ..
        
        REM Re-establish environment variables before calling edksetup.bat
        echo Re-establishing environment variables before EDK2 setup...
        
        REM Re-detect and set NASM_PREFIX
        where nasm >nul 2>&1
        if errorlevel 1 (
          if exist "%ProgramData%\chocolatey\bin\nasm.exe" (
            set "NASM_PREFIX=%ProgramData%\chocolatey\bin\"
            set "PATH=%ProgramData%\chocolatey\bin;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\tools\nasm\nasm.exe" (
            set "NASM_PREFIX=C:\tools\nasm\"
            set "PATH=C:\tools\nasm;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else if exist "C:\Program Files\NASM\nasm.exe" (
            set "NASM_PREFIX=C:\Program Files\NASM\"
            set "PATH=C:\Program Files\NASM;%PATH%"
            echo Re-set NASM_PREFIX=%NASM_PREFIX%
          ) else (
            set "NASM_PREFIX=C:\tools\nasm\"
            echo Set default NASM_PREFIX=%NASM_PREFIX%
          )
        ) else (
          for /f "tokens=*" %%i in ('where nasm') do (
            set "NASM_PATH=%%i"
            goto :found_nasm2
          )
          :found_nasm2
          for %%i in ("%NASM_PATH%") do set "NASM_PREFIX=%%~dpi"
          echo Re-set NASM_PREFIX=%NASM_PREFIX%
        )
        
        REM Re-set CLANG_BIN
        if exist "C:\Program Files\LLVM\bin\clang.exe" (
          set "CLANG_BIN=C:\Program Files\LLVM\bin\"
          echo Re-set CLANG_BIN=%CLANG_BIN%
        )
        
        REM Re-set CYGWIN_HOME to empty to suppress warning
        set "CYGWIN_HOME="
        echo Set CYGWIN_HOME to empty to suppress warning
        
        REM Call edksetup.bat again after BaseTools build to refresh environment
        echo Refreshing EDK2 environment after BaseTools build...
        call edksetup.bat
        
        REM Verify BASE_TOOLS_PATH is still set after refresh
        echo Verifying BASE_TOOLS_PATH after refresh...
        if "%BASE_TOOLS_PATH%"=="" (
          echo WARNING: BASE_TOOLS_PATH lost after refresh, setting manually...
          set "BASE_TOOLS_PATH=%WORKSPACE%\BaseTools"
          echo Set BASE_TOOLS_PATH to: %BASE_TOOLS_PATH%
        ) else (
          echo BASE_TOOLS_PATH confirmed: %BASE_TOOLS_PATH%
        )
        
        REM Verify EDK_TOOLS_BIN is set correctly after edksetup
        echo Verifying EDK_TOOLS_BIN environment variable...
        if "%EDK_TOOLS_BIN%"=="" (
          echo EDK_TOOLS_BIN not set by edksetup, setting manually...
          set "EDK_TOOLS_BIN=%WORKSPACE%\BaseTools\Bin\Win32"
          echo Set EDK_TOOLS_BIN to: %EDK_TOOLS_BIN%
        ) else (
          echo EDK_TOOLS_BIN is: %EDK_TOOLS_BIN%
        )
        
        REM Verify the path exists
        if not exist "%EDK_TOOLS_BIN%" (
          echo WARNING: EDK_TOOLS_BIN path does not exist: %EDK_TOOLS_BIN%
          echo Attempting to find correct BaseTools path...
          
          if exist "%WORKSPACE%\BaseTools\Bin\Win32" (
            set "EDK_TOOLS_BIN=%WORKSPACE%\BaseTools\Bin\Win32"
            echo Corrected EDK_TOOLS_BIN to: %EDK_TOOLS_BIN%
          ) else (
            echo ERROR: Cannot find BaseTools directory
            echo WORKSPACE is: %WORKSPACE%
            dir "%WORKSPACE%\BaseTools" 2>nul || echo BaseTools directory not found
            exit /b 1
          )
        ) else (
          echo ✅ EDK_TOOLS_BIN path verified: %EDK_TOOLS_BIN%
        )
        
        REM Reset CL for application build (we want warnings for our code)
        set CL=
        
        REM Build ACPIPatcher with custom debug level
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t VS2022 ^
              -p ACPIPatcherPkg\ACPIPatcherPkg.dsc ^
              -D DEBUG_LEVEL=${{ env.DEBUG_LEVEL }}
    
    - name: Verify Build and Create Distribution Package (Windows)
      if: matrix.os == 'windows'
      shell: powershell
      run: |
        cd edk2
        
        # Dynamic discovery of EFI artifacts
        Write-Host "=== Dynamic Build Artifact Discovery ==="
        Write-Host "Searching for .efi files in Build directory..."
        $EfiFiles = Get-ChildItem -Path "Build" -Recurse -Filter "*.efi" -ErrorAction SilentlyContinue
        if ($EfiFiles) {
          foreach ($file in $EfiFiles) {
            Write-Host "Found EFI file: $($file.FullName)"
          }
        } else {
          Write-Host "No .efi files found"
        }
        
        # Find main EFI files
        $EFI_PATH = (Get-ChildItem -Path "Build" -Recurse -Filter "ACPIPatcher.efi" -ErrorAction SilentlyContinue | Select-Object -First 1).FullName
        $DXE_PATH = (Get-ChildItem -Path "Build" -Recurse -Filter "ACPIPatcherDxe.efi" -ErrorAction SilentlyContinue | Select-Object -First 1).FullName
        
        # Create distribution package
        $DIST_DIR = "ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-windows"
        New-Item -ItemType Directory -Path $DIST_DIR -Force
        
        # Copy EFI files if found
        if ($EFI_PATH -and (Test-Path $EFI_PATH)) {
          Copy-Item $EFI_PATH $DIST_DIR/
          Write-Host "✅ Copied ACPIPatcher.efi to distribution package"
        } else {
          Write-Warning "ACPIPatcher.efi not found, creating placeholder file"
          "BUILD_FAILED: Could not find ACPIPatcher.efi" | Out-File -FilePath "$DIST_DIR\ACPIPatcher.efi.missing" -Encoding utf8
        }
        
        if ($DXE_PATH -and (Test-Path $DXE_PATH)) {
          Copy-Item $DXE_PATH $DIST_DIR/
          Write-Host "✅ Copied ACPIPatcherDxe.efi to distribution package"
        } else {
          Write-Warning "ACPIPatcherDxe.efi not found, creating placeholder file"
          "BUILD_FAILED: Could not find ACPIPatcherDxe.efi" | Out-File -FilePath "$DIST_DIR\ACPIPatcherDxe.efi.missing" -Encoding utf8
        }
        
        # Try to find any other EFI files as fallback
        $OtherEfiFiles = Get-ChildItem -Path "Build" -Recurse -Filter "*.efi" -ErrorAction SilentlyContinue
        if ($OtherEfiFiles) {
          Write-Host "Found additional EFI files, copying to package..."
          foreach ($file in $OtherEfiFiles) {
            Copy-Item $file.FullName "$DIST_DIR\" -ErrorAction SilentlyContinue
            Write-Host "  - Copied: $($file.Name)"
          }
        }
        
        # Copy documentation
        Write-Host "Copying documentation files..."
        $SOURCE_PATH = "..\acpipatcher"
        
        if (Test-Path "$SOURCE_PATH\Build\ACPI") {
          Copy-Item -Path "$SOURCE_PATH\Build\ACPI" -Destination "$DIST_DIR\" -Recurse -ErrorAction SilentlyContinue
        } else {
          Write-Warning "ACPI test directory not found"
        }
        
        foreach ($doc in @("README.md", "DEBUG_GUIDE.md", "IMPROVEMENTS.md")) {
          if (Test-Path "$SOURCE_PATH\$doc") {
            Copy-Item -Path "$SOURCE_PATH\$doc" -Destination "$DIST_DIR\" -ErrorAction SilentlyContinue
          } else {
            Write-Warning "$doc not found"
          }
        }
        
        # Create build info
        $BUILD_INFO = @"
ACPIPatcher Build Information
============================
Version: $(git -C ..\acpipatcher describe --tags --always 2>$null)
Commit: $(git -C ..\acpipatcher rev-parse HEAD 2>$null)
Build Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
Architecture: ${{ matrix.arch }}
Build Type: ${{ matrix.build_type }}
Debug Level: ${{ env.DEBUG_LEVEL }}
Toolchain: VS2022
Platform: Windows
"@
        
        $BUILD_INFO | Out-File -FilePath "$DIST_DIR\BUILD_INFO.txt" -Encoding UTF8
        
        # Create zip archive
        Compress-Archive -Path $DIST_DIR -DestinationPath "$DIST_DIR.zip" -Force
      continue-on-error: true

  notification:
    name: Build Notification
    runs-on: ubuntu-latest
    needs: [build-linux, build-macos, build-windows, test-static-analysis]
    if: always()
    
    steps:
    - name: Determine Status
      id: status
      run: |
        if [[ "${{ needs.build-linux.result }}" == "success" && 
              "${{ needs.build-macos.result }}" ==