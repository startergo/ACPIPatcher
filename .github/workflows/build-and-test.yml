name: Build and Test ACPIPatcher

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      debug_level:
        description: 'Debug Level (1-4)'
        required: false
        default: '3'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'

env:
  EDK2_VERSION: edk2-stable202405
  DEBUG_LEVEL: ${{ github.event.inputs.debug_level || '3' }}

jobs:
  build-linux:
    name: Build on Ubuntu (GCC5)
    runs-on: ubuntu-latest
    
    strategy:
      # Setting fail-fast to false ensures that all matrix combinations run independently
      # If one architecture (IA32) fails, builds for other architectures (X64) will continue
      fail-fast: false
      matrix:
        arch: [X64, IA32]
        build_type: [RELEASE, DEBUG]
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'
    
    - name: Install Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential nasm uuid-dev gcc-multilib
    
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v4
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-ubuntu-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          git submodule update --init --recommend-shallow || echo "Warning: Some submodules failed to initialize"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      run: |
        cp -r acpipatcher/ACPIPatcherPkg edk2/
    
    - name: Setup EDK2 Environment
      run: |
        cd edk2
        . edksetup.sh
        make -C BaseTools
    
    - name: Build ACPIPatcher
      run: |
        cd edk2
        . edksetup.sh
        
        # Build with custom debug level
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t GCC5 \
              -p ACPIPatcherPkg/ACPIPatcherPkg.dsc \
              -D DEBUG_LEVEL=${{ env.DEBUG_LEVEL }}
    
    - name: Verify Build Output
      run: |
        cd edk2
        
        echo "Exploring actual build directory structure..."
        echo "=== Top-level Build directory ==="
        ls -la Build/ || echo "No Build directory found"
        
        echo "=== All subdirectories in Build/ ==="
        find Build/ -type d -name "*ACPIPatcher*" 2>/dev/null || echo "No ACPIPatcher directories found"
        
        echo "=== All .efi files in Build/ ==="
        find Build/ -name "*.efi" 2>/dev/null || echo "No .efi files found"
        
        # Try the expected path first
        BUILD_DIR="Build/ACPIPatcherPkg/${{ matrix.build_type }}_GCC5/${{ matrix.arch }}"
        echo "=== Checking expected path: $BUILD_DIR ==="
        ls -la "$BUILD_DIR/" || echo "Expected path not found"
        
        # Find the actual path to .efi files
        echo "=== Finding actual .efi file locations ==="
        EFI_PATHS=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null || true)
        DXE_PATHS=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null || true)
        
        if [ -n "$EFI_PATHS" ]; then
          echo "✅ Found ACPIPatcher.efi at:"
          echo "$EFI_PATHS"
          for path in $EFI_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcher.efi not found anywhere"
          exit 1
        fi
        
        if [ -n "$DXE_PATHS" ]; then
          echo "✅ Found ACPIPatcherDxe.efi at:"
          echo "$DXE_PATHS"
          for path in $DXE_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcherDxe.efi not found anywhere"
          exit 1
        fi
    
    - name: Create Distribution Package
      run: |
        cd edk2
        DIST_DIR="ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-linux"
        
        # Find the actual paths to .efi files
        EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
        DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
        
        if [ -z "$EFI_PATH" ] || [ -z "$DXE_PATH" ]; then
          echo "❌ Could not find .efi files for distribution package"
          exit 1
        fi
        
        mkdir -p "$DIST_DIR"
        cp "$EFI_PATH" "$DIST_DIR/"
        cp "$DXE_PATH" "$DIST_DIR/"
        
        # Copy documentation and test files using dynamic path discovery
        echo "Copying documentation and test files..."
        
        # Find the actual path to the source repository
        SOURCE_PATH="../acpipatcher"
        if [ ! -d "$SOURCE_PATH" ]; then
          SOURCE_PATH="$(find .. -name "ACPIPatcherPkg" -type d | head -1 | xargs dirname)"
        fi
        
        if [ -d "$SOURCE_PATH/Build/ACPI" ]; then
          cp -r "$SOURCE_PATH/Build/ACPI" "$DIST_DIR/" || echo "Warning: Could not copy ACPI test files"
        else
          echo "Warning: ACPI test directory not found at $SOURCE_PATH/Build/ACPI"
        fi
        
        if [ -f "$SOURCE_PATH/README.md" ]; then
          cp "$SOURCE_PATH/README.md" "$DIST_DIR/"
        else
          echo "Warning: README.md not found at $SOURCE_PATH/README.md"
        fi
        
        if [ -f "$SOURCE_PATH/DEBUG_GUIDE.md" ]; then
          cp "$SOURCE_PATH/DEBUG_GUIDE.md" "$DIST_DIR/" || echo "Warning: Could not copy DEBUG_GUIDE.md"
        else
          echo "Warning: DEBUG_GUIDE.md not found"
        fi
        
        if [ -f "$SOURCE_PATH/IMPROVEMENTS.md" ]; then
          cp "$SOURCE_PATH/IMPROVEMENTS.md" "$DIST_DIR/" || echo "Warning: Could not copy IMPROVEMENTS.md"
        else
          echo "Warning: IMPROVEMENTS.md not found"
        fi
        
        # Create version info
        echo "ACPIPatcher Build Information" > "$DIST_DIR/BUILD_INFO.txt"
        echo "============================" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Version: $(git -C ../acpipatcher describe --tags --always)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Commit: $(git -C ../acpipatcher rev-parse HEAD)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Date: $(date -u)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Architecture: ${{ matrix.arch }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Type: ${{ matrix.build_type }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Debug Level: ${{ env.DEBUG_LEVEL }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Toolchain: GCC5" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Platform: Ubuntu Linux" >> "$DIST_DIR/BUILD_INFO.txt"
        
        tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
    
    - name: Validate Build Artifacts
      # Continue on error to allow the workflow to complete even if validation fails
      continue-on-error: true
      run: |
        cd edk2
        
        # Run comprehensive build validation
        if [ -f "../acpipatcher/.github/scripts/test-build-artifacts.sh" ]; then
          echo "Running comprehensive build artifact validation..."
          bash ../acpipatcher/.github/scripts/test-build-artifacts.sh "$(pwd)" "${{ matrix.arch }}" "${{ matrix.build_type }}" "GCC5" || {
            echo "❌ Build artifact validation failed, but continuing workflow"
          }
        else
          echo "Validation script not found, running basic checks..."
          
          # Use find to locate the EFI files wherever they might be
          EFI_PATHS=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null || true)
          DXE_PATHS=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null || true)
          
          if [ -n "$EFI_PATHS" ] && [ -n "$DXE_PATHS" ]; then
            echo "✅ Basic validation passed - required EFI files present:"
            echo "$EFI_PATHS"
            echo "$DXE_PATHS"
          else
            echo "❌ Basic validation failed - required EFI files missing"
            # Don't exit with error to allow workflow to continue
          fi
        fi
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      # Continue on error if the artifact cannot be uploaded
      continue-on-error: true
      with:
        name: ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-linux
        path: edk2/ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-linux.tar.gz
        retention-days: 30
        # Set to 'warn' to prevent failure if no artifacts are found
        if-no-files-found: warn

  build-macos:
    name: Build on macOS (Xcode)
    runs-on: macos-13
    
    strategy:
      # Setting fail-fast to false ensures that all matrix combinations run independently
      fail-fast: false
      matrix:
        arch: [X64]
        build_type: [RELEASE, DEBUG]
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'
    
    - name: Install Dependencies
      run: |
        brew install nasm mtoc
    
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v4
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-macos-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          git submodule update --init --recommend-shallow || echo "Warning: Some submodules failed to initialize"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      run: |
        cp -r acpipatcher/ACPIPatcherPkg edk2/
    
    - name: Setup EDK2 Environment
      run: |
        cd edk2
        . edksetup.sh
        make -C BaseTools
    
    - name: Build ACPIPatcher
      run: |
        cd edk2
        . edksetup.sh
        
        # Build with custom debug level
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t XCODE5 \
              -p ACPIPatcherPkg/ACPIPatcherPkg.dsc \
              -D DEBUG_LEVEL=${{ env.DEBUG_LEVEL }}
    
    - name: Verify Build Output
      run: |
        cd edk2
        
        echo "Exploring actual build directory structure..."
        echo "=== Top-level Build directory ==="
        ls -la Build/ || echo "No Build directory found"
        
        echo "=== All subdirectories in Build/ ==="
        find Build/ -type d -name "*ACPIPatcher*" 2>/dev/null || echo "No ACPIPatcher directories found"
        
        echo "=== All .efi files in Build/ ==="
        find Build/ -name "*.efi" 2>/dev/null || echo "No .efi files found"
        
        # Try the expected path first
        BUILD_DIR="Build/ACPIPatcherPkg/${{ matrix.build_type }}_XCODE5/${{ matrix.arch }}"
        echo "=== Checking expected path: $BUILD_DIR ==="
        ls -la "$BUILD_DIR/" || echo "Expected path not found"
        
        # Find the actual path to .efi files
        echo "=== Finding actual .efi file locations ==="
        EFI_PATHS=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null || true)
        DXE_PATHS=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null || true)
        
        if [ -n "$EFI_PATHS" ]; then
          echo "✅ Found ACPIPatcher.efi at:"
          echo "$EFI_PATHS"
          for path in $EFI_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcher.efi not found anywhere"
          exit 1
        fi
        
        if [ -n "$DXE_PATHS" ]; then
          echo "✅ Found ACPIPatcherDxe.efi at:"
          echo "$DXE_PATHS"
          for path in $DXE_PATHS; do
            file "$path"
          done
        else
          echo "❌ ACPIPatcherDxe.efi not found anywhere"
          exit 1
        fi
    
    - name: Create Distribution Package
      run: |
        cd edk2
        DIST_DIR="ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-macos"
        
        # Find the actual paths to .efi files
        EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
        DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
        
        if [ -z "$EFI_PATH" ] || [ -z "$DXE_PATH" ]; then
          echo "❌ Could not find .efi files for distribution package"
          exit 1
        fi
        
        mkdir -p "$DIST_DIR"
        cp "$EFI_PATH" "$DIST_DIR/"
        cp "$DXE_PATH" "$DIST_DIR/"
        
        # Copy documentation and test files using dynamic path discovery
        echo "Copying documentation and test files..."
        
        # Find the actual path to the source repository
        SOURCE_PATH="../acpipatcher"
        if [ ! -d "$SOURCE_PATH" ]; then
          SOURCE_PATH="$(find .. -name "ACPIPatcherPkg" -type d | head -1 | xargs dirname)"
        fi
        
        if [ -d "$SOURCE_PATH/Build/ACPI" ]; then
          cp -r "$SOURCE_PATH/Build/ACPI" "$DIST_DIR/" || echo "Warning: Could not copy ACPI test files"
        else
          echo "Warning: ACPI test directory not found at $SOURCE_PATH/Build/ACPI"
        fi
        
        if [ -f "$SOURCE_PATH/README.md" ]; then
          cp "$SOURCE_PATH/README.md" "$DIST_DIR/"
        else
          echo "Warning: README.md not found at $SOURCE_PATH/README.md"
        fi
        
        if [ -f "$SOURCE_PATH/DEBUG_GUIDE.md" ]; then
          cp "$SOURCE_PATH/DEBUG_GUIDE.md" "$DIST_DIR/" || echo "Warning: Could not copy DEBUG_GUIDE.md"
        else
          echo "Warning: DEBUG_GUIDE.md not found"
        fi
        
        if [ -f "$SOURCE_PATH/IMPROVEMENTS.md" ]; then
          cp "$SOURCE_PATH/IMPROVEMENTS.md" "$DIST_DIR/" || echo "Warning: Could not copy IMPROVEMENTS.md"
        else
          echo "Warning: IMPROVEMENTS.md not found"
        fi
        
        # Create version info
        echo "ACPIPatcher Build Information" > "$DIST_DIR/BUILD_INFO.txt"
        echo "============================" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Version: $(git -C ../acpipatcher describe --tags --always)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Commit: $(git -C ../acpipatcher rev-parse HEAD)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Date: $(date -u)" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Architecture: ${{ matrix.arch }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Build Type: ${{ matrix.build_type }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Debug Level: ${{ env.DEBUG_LEVEL }}" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Toolchain: XCODE5" >> "$DIST_DIR/BUILD_INFO.txt"
        echo "Platform: macOS" >> "$DIST_DIR/BUILD_INFO.txt"
        
        tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
    
    - name: Validate Build Artifacts
      # Continue on error to allow the workflow to complete even if validation fails
      continue-on-error: true
      run: |
        cd edk2
        
        # Run comprehensive build validation
        if [ -f "../acpipatcher/.github/scripts/test-build-artifacts.sh" ]; then
          echo "Running comprehensive build artifact validation..."
          bash ../acpipatcher/.github/scripts/test-build-artifacts.sh "$(pwd)" "${{ matrix.arch }}" "${{ matrix.build_type }}" "XCODE5" || {
            echo "❌ Build artifact validation failed, but continuing workflow"
          }
        else
          echo "Validation script not found, running basic checks..."
          
          # Find actual .efi file paths
          EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
          DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
          
          if [ -n "$EFI_PATH" ] && [ -n "$DXE_PATH" ]; then
            echo "✅ Basic validation passed - required EFI files present"
            echo "  ACPIPatcher.efi: $EFI_PATH"
            echo "  ACPIPatcherDxe.efi: $DXE_PATH"
          else
            echo "❌ Basic validation failed - required EFI files missing"
            # Don't exit with error to allow workflow to continue
          fi
        fi
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      # Continue on error if the artifact cannot be uploaded
      continue-on-error: true
      with:
        name: ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-macos
        path: edk2/ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-macos.tar.gz
        retention-days: 30
        # Set to 'warn' to prevent failure if no artifacts are found
        if-no-files-found: warn

  build-windows:
    name: Build on Windows (VS2022)
    runs-on: windows-latest
    
    strategy:
      # Setting fail-fast to false ensures that all matrix combinations run independently
      # If one architecture (IA32) fails, builds for other architectures (X64) will continue
      fail-fast: false
      matrix:
        arch: [X64, IA32]
        build_type: [RELEASE, DEBUG]
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'
    
    - name: Setup MSYS2 and Build Tools
      uses: msys2/setup-msys2@v2
      with:
        msystem: MSYS
        update: false
        install: >-
          nasm
          make
          mingw-w64-x86_64-clang
          mingw-w64-x86_64-lld

    - name: Make MSYS2 Tools Available for Windows Batch
      shell: powershell
      run: |
        # Detect MSYS2 installation path
        $msys2Root = if (Test-Path "C:\msys64") { "C:\msys64" } else { "D:\msys64" }
        Write-Host "MSYS2 root detected: $msys2Root"
        
        # Add MSYS2 bin paths to Windows PATH for batch script access
        $msys2BinPath = "$msys2Root\usr\bin"
        $mingw64BinPath = "$msys2Root\mingw64\bin"
        
        Write-Host "Adding to PATH: $msys2BinPath"
        Write-Host "Adding to PATH: $mingw64BinPath"
        
        # Add to GITHUB_PATH for persistence across steps
        Add-Content $env:GITHUB_PATH "$msys2BinPath"
        Add-Content $env:GITHUB_PATH "$mingw64BinPath"
        
        # Verify tools are accessible
        & "$msys2BinPath\nasm.exe" -v
        if ($LASTEXITCODE -eq 0) {
          Write-Host "✅ NASM is accessible from Windows"
        } else {
          Write-Host "⚠️ NASM verification failed"
        }
        
        & "$msys2BinPath\make.exe" --version
        if ($LASTEXITCODE -eq 0) {
          Write-Host "✅ Make is accessible from Windows"
        } else {
          Write-Host "⚠️ Make verification failed"
        }
        
        & "$mingw64BinPath\clang.exe" --version
        if ($LASTEXITCODE -eq 0) {
          Write-Host "✅ Clang is accessible from Windows"
        } else {
          Write-Host "⚠️ Clang verification failed"
        }
    
    - name: Setup Visual Studio Environment
      uses: microsoft/setup-msbuild@v1.3.3
      
    - name: Setup Windows Build Environment
      uses: ilammy/msvc-dev-cmd@v1.13.0
      with:
        arch: x64
    
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v4
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-windows-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      shell: bash
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          git submodule update --init --recommend-shallow || echo "Warning: Some submodules failed to initialize"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      run: |
        xcopy /E /I acpipatcher\ACPIPatcherPkg edk2\ACPIPatcherPkg
    
    - name: Setup EDK2 Environment and Build
      shell: cmd
      run: |
        cd edk2
        
        REM ====================================================================
        REM Simplified setup using MSYS2 tools from msys2/setup-msys2 action
        REM ====================================================================
        echo Setting up EDK2 environment with MSYS2 tools...
        
        REM Verify NASM is accessible (should be available via GITHUB_PATH)
        nasm -v >nul 2>&1
        if errorlevel 1 (
          echo ❌ NASM not accessible - checking MSYS2 paths
          if exist "C:\msys64\usr\bin\nasm.exe" (
            set "PATH=C:\msys64\usr\bin;%PATH%"
            echo ✅ Added MSYS2 NASM to PATH
          ) else (
            echo ❌ NASM not found in MSYS2
            exit /b 1
          )
        ) else (
          echo ✅ NASM is accessible
        )
        
        REM Set up workspace
        set "WORKSPACE=%GITHUB_WORKSPACE%\edk2"
        echo Set WORKSPACE to: %WORKSPACE%
        
        REM Call edksetup.bat to initialize EDK2 environment
        echo Calling edksetup.bat...
        call edksetup.bat || (
          echo ❌ edksetup.bat failed
          exit /b 1
        )
        
        REM Verify BASE_TOOLS_PATH is set
        if "%BASE_TOOLS_PATH%"=="" (
          set "BASE_TOOLS_PATH=%WORKSPACE%\BaseTools"
          echo Set BASE_TOOLS_PATH to: %BASE_TOOLS_PATH%
        ) else (
          echo BASE_TOOLS_PATH is: %BASE_TOOLS_PATH%
        )
        
        REM Build BaseTools
        echo Building BaseTools...
        cd BaseTools
        
        REM Ensure Win32 directory exists
        if not exist "Bin\Win32" mkdir "Bin\Win32"
        
        REM Build BaseTools with nmake
        nmake
        if errorlevel 1 (
          echo ❌ BaseTools build failed
          exit /b 1
        )
        
        echo ✅ BaseTools build completed
        cd ..
        
        REM Build ACPIPatcher
        echo Building ACPIPatcher...
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t VS2022 ^
              -p ACPIPatcherPkg\ACPIPatcherPkg.dsc ^
              -D DEBUG_LEVEL=${{ env.DEBUG_LEVEL }}
        
        if errorlevel 1 (
          echo ❌ ACPIPatcher build failed
          exit /b 1
        ) else (
          echo ✅ ACPIPatcher build completed successfully
        )
    
    - name: Verify Build Output
      shell: powershell
      continue-on-error: true
      run: |
        cd edk2
        $BUILD_DIR = "Build\ACPIPatcherPkg\${{ matrix.build_type }}_VS2022\${{ matrix.arch }}"
        
        Write-Host "Build directory contents:"
        Get-ChildItem "$BUILD_DIR" -ErrorAction SilentlyContinue | Format-Table
        
        # Check if binaries exist
        if (Test-Path "$BUILD_DIR\ACPIPatcher.efi") {
          Write-Host "✅ ACPIPatcher.efi built successfully"
          Get-ItemProperty "$BUILD_DIR\ACPIPatcher.efi" | Select-Object Name, Length, LastWriteTime
        } else {
          Write-Host "❌ ACPIPatcher.efi not found"
          exit 1
        }
        
        if (Test-Path "$BUILD_DIR\ACPIPatcherDxe.efi") {
          Write-Host "✅ ACPIPatcherDxe.efi built successfully" 
          Get-ItemProperty "$BUILD_DIR\ACPIPatcherDxe.efi" | Select-Object Name, Length, LastWriteTime
        } else {
          Write-Host "❌ ACPIPatcherDxe.efi not found"
          exit 1
        }
    
    - name: Create Distribution Package
      shell: powershell
      continue-on-error: true
      run: |
        cd edk2
        $BUILD_DIR = "Build\ACPIPatcherPkg\${{ matrix.build_type }}_VS2022\${{ matrix.arch }}"
        $DIST_DIR = "ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-windows"
        
        New-Item -ItemType Directory -Path "$DIST_DIR" -Force
        
        # Try to copy EFI files - create placeholders if not found
        if (Test-Path "$BUILD_DIR\ACPIPatcher.efi") {
            Copy-Item "$BUILD_DIR\ACPIPatcher.efi" "$DIST_DIR\" -ErrorAction SilentlyContinue
            Write-Host "✅ Copied ACPIPatcher.efi to distribution package"
        } else {
            Write-Host "⚠️ ACPIPatcher.efi not found, creating placeholder"
            "This is a placeholder for ACPIPatcher.efi that failed to build" | Out-File -FilePath "$DIST_DIR\ACPIPatcher.efi.placeholder" -Encoding utf8
        }
        
        if (Test-Path "$BUILD_DIR\ACPIPatcherDxe.efi") {
            Copy-Item "$BUILD_DIR\ACPIPatcherDxe.efi" "$DIST_DIR\" -ErrorAction SilentlyContinue
            Write-Host "✅ Copied ACPIPatcherDxe.efi to distribution package"
        } else {
            Write-Host "⚠️ ACPIPatcherDxe.efi not found, creating placeholder"
            "This is a placeholder for ACPIPatcherDxe.efi that failed to build" | Out-File -FilePath "$DIST_DIR\ACPIPatcherDxe.efi.placeholder" -Encoding utf8
        }
        
        # Try to find any .efi files that might have been built
        Write-Host "Searching for any .efi files built..."
        $efiFiles = Get-ChildItem -Path "Build\" -Filter "*.efi" -Recurse -ErrorAction SilentlyContinue
        foreach ($file in $efiFiles) {
            Write-Host "Found additional EFI file: $($file.FullName)"
            Copy-Item $file.FullName "$DIST_DIR\" -ErrorAction SilentlyContinue
        }
        
        # Copy ACPI directory if it exists
        if (Test-Path "..\acpipatcher\Build\ACPI") {
            Copy-Item "..\acpipatcher\Build\ACPI" "$DIST_DIR\" -Recurse -ErrorAction SilentlyContinue
            Write-Host "✅ Copied ACPI directory to distribution package"
        } elseif (Test-Path "Build\ACPI") {
            Copy-Item "Build\ACPI" "$DIST_DIR\" -Recurse -ErrorAction SilentlyContinue
            Write-Host "✅ Copied ACPI directory to distribution package"
        } else {
            Write-Host "⚠️ ACPI directory not found"
        }
        
        # Copy documentation
        if (Test-Path "..\acpipatcher\README.md") {
            Copy-Item "..\acpipatcher\README.md" "$DIST_DIR\" -ErrorAction SilentlyContinue
            Write-Host "✅ Copied README.md to distribution package"
        }
        
        # Copy any additional documentation if available
        $docFiles = @("LATEST_BUILD_FIXES.md", "DEBUG_GUIDE.md", "EFI_1X_COMPATIBILITY.md")
        foreach ($doc in $docFiles) {
            if (Test-Path "..\acpipatcher\$doc") {
                Copy-Item "..\acpipatcher\$doc" "$DIST_DIR\" -ErrorAction SilentlyContinue
                Write-Host "✅ Copied $doc to distribution package"
            }
        }
        if (Test-Path "acpipatcher\DEBUG_GUIDE.md") {
          Copy-Item "acpipatcher\DEBUG_GUIDE.md" "$DIST_DIR\"
        }
        if (Test-Path "acpipatcher\IMPROVEMENTS.md") {
          Copy-Item "acpipatcher\IMPROVEMENTS.md" "$DIST_DIR\"
        }
        
        # Create version info
        $version = git -C acpipatcher describe --tags --always
        $commit = git -C acpipatcher rev-parse HEAD
        $buildDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
        
        # Create build info as individual lines to avoid heredoc issues
        $buildInfoFile = "$DIST_DIR\BUILD_INFO.txt"
        Set-Content -Path $buildInfoFile -Value "ACPIPatcher Build Information"
        Add-Content -Path $buildInfoFile -Value "============================"
        Add-Content -Path $buildInfoFile -Value "Version: $version"
        Add-Content -Path $buildInfoFile -Value "Commit: $commit"
        Add-Content -Path $buildInfoFile -Value "Build Date: $buildDate"
        Add-Content -Path $buildInfoFile -Value "Architecture: ${{ matrix.arch }}"
        Add-Content -Path $buildInfoFile -Value "Build Type: ${{ matrix.build_type }}"
        Add-Content -Path $buildInfoFile -Value "Debug Level: ${{ env.DEBUG_LEVEL }}"
        Add-Content -Path $buildInfoFile -Value "Toolchain: VS2022"
        Add-Content -Path $buildInfoFile -Value "Platform: Windows"
        
        Compress-Archive -Path "$DIST_DIR" -DestinationPath "$DIST_DIR.zip"
    
    - name: Validate Build Artifacts
      shell: powershell
      # Continue on error to allow the workflow to complete even if validation fails
      continue-on-error: true
      run: |
        cd edk2
        $BUILD_DIR = "Build\ACPIPatcherPkg\${{ matrix.build_type }}_VS2022\${{ matrix.arch }}"
        
        Write-Host "Running build artifact validation..."
        
        # Check if required EFI files exist and have reasonable sizes
        $requiredFiles = @("ACPIPatcher.efi", "ACPIPatcherDxe.efi")
        $allValid = $true
        
        # First check expected location
        foreach ($file in $requiredFiles) {
          $filePath = Join-Path $BUILD_DIR $file
          if (Test-Path $filePath) {
            $fileInfo = Get-ItemProperty $filePath
            $fileSize = $fileInfo.Length
            
            if ($fileSize -gt 1024 -and $fileSize -lt 10485760) {
              Write-Host "✅ Valid EFI file: $file ($fileSize bytes)"
            } else {
              Write-Host "❌ Invalid EFI file size: $file ($fileSize bytes)"
              $allValid = $false
            }
          } else {
            Write-Host "❌ Missing EFI file: $file at expected location $filePath"
            $allValid = $false
            
            # Try dynamic discovery if not found at expected location
            Write-Host "Searching for $file in Build directory..."
            $foundFiles = Get-ChildItem -Path "Build" -Recurse -Filter $file -ErrorAction SilentlyContinue
            if ($foundFiles) {
              Write-Host "✅ Found $file at alternative location(s):"
              foreach ($foundFile in $foundFiles) {
                Write-Host "  - $($foundFile.FullName)"
              }
              $allValid = $true
            }
          }
        }
        
        if (-not $allValid) {
          Write-Host "❌ Build artifact validation failed, but continuing workflow"
          # Do not exit with error to allow the workflow to continue
        } else {
          Write-Host "✅ Build artifact validation passed"
        }
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      # Continue on error if the artifact cannot be uploaded
      continue-on-error: true
      with:
        name: ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-windows
        path: edk2/ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-windows
        retention-days: 30
        # Set to 'warn' to prevent failure if no artifacts are found
        if-no-files-found: warn

  test-static-analysis:
    name: Static Code Analysis
    runs-on: ubuntu-latest
    needs: [build-linux]
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Install Analysis Tools
      run: |
        sudo apt-get update
        sudo apt-get install -y cppcheck clang-tidy
    
    - name: Run CPPCheck
      run: |
        echo "Running CPPCheck static analysis..."
        cppcheck --enable=all --inconclusive --xml --xml-version=2 \
                 --suppress=missingIncludeSystem \
                 --suppress=unusedFunction \
                 ACPIPatcherPkg/ACPIPatcher/ 2> cppcheck-results.xml || true
        
        # Convert to human readable format
        if [ -s cppcheck-results.xml ]; then
          echo "CPPCheck found issues:"
          cat cppcheck-results.xml
        else
          echo "✅ CPPCheck analysis passed"
        fi
    
    - name: Check Code Style
      run: |
        echo "Checking code formatting..."
        
        # Check for consistent indentation (spaces vs tabs)
        if grep -r $'\t' ACPIPatcherPkg/ACPIPatcher/ --include="*.c" --include="*.h"; then
          echo "⚠️  Warning: Found tab characters, consider using spaces"
        else
          echo "✅ Indentation check passed"
        fi
        
        # Check for trailing whitespace
        if grep -r ' $' ACPIPatcherPkg/ACPIPatcher/ --include="*.c" --include="*.h"; then
          echo "⚠️  Warning: Found trailing whitespace"
        else
          echo "✅ Trailing whitespace check passed"
        fi
    
    - name: Upload Analysis Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: static-analysis-results
        path: cppcheck-results.xml
        retention-days: 7

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [build-linux, build-macos, build-windows, test-static-analysis]
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Download All Artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
    
    - name: Prepare Release Assets
      run: |
        mkdir release-assets
        
        # Copy all build artifacts to release directory
        find artifacts -name "*.tar.gz" -o -name "*.zip" | while read file; do
          cp "$file" release-assets/
        done
        
        # Create a combined release package
        mkdir ACPIPatcher-All-Platforms
        
        # Extract all builds to combined package
        cd release-assets
        for archive in *.tar.gz *.zip; do
          if [[ $archive == *.tar.gz ]]; then
            tar -xzf "$archive"
          else
            unzip -q "$archive"
          fi
        done
        cd ..
        
        # Copy documentation
        cp README.md ACPIPatcher-All-Platforms/ || true
        cp DEBUG_GUIDE.md ACPIPatcher-All-Platforms/ || true
        cp IMPROVEMENTS.md ACPIPatcher-All-Platforms/ || true
        cp LICENSE ACPIPatcher-All-Platforms/ || true
        
        # Create the combined archive
        tar -czf release-assets/ACPIPatcher-All-Platforms.tar.gz ACPIPatcher-All-Platforms
    
    - name: Generate Release Notes
      id: release_notes
      run: |
        echo "## ACPIPatcher Release ${GITHUB_REF#refs/tags/}" > release_notes.md
        echo "" >> release_notes.md
        echo "### Build Information" >> release_notes.md
        echo "- **Build Date:** $(date -u)" >> release_notes.md
        echo "- **Commit:** ${GITHUB_SHA:0:8}" >> release_notes.md
        echo "- **EDK II Version:** ${{ env.EDK2_VERSION }}" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Supported Platforms" >> release_notes.md
        echo "- ✅ **Linux (Ubuntu)** - GCC5 toolchain" >> release_notes.md
        echo "- ✅ **macOS** - Xcode5 toolchain" >> release_notes.md
        echo "- ✅ **Windows** - VS2022 toolchain" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Available Architectures" >> release_notes.md
        echo "- **X64** - 64-bit Intel/AMD (Primary)" >> release_notes.md
        echo "- **IA32** - 32-bit Intel/AMD (Legacy)" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Package Contents" >> release_notes.md
        echo "- \`ACPIPatcher.efi\` - Application version" >> release_notes.md
        echo "- \`ACPIPatcherDxe.efi\` - Driver version" >> release_notes.md
        echo "- \`ACPI/\` - Sample ACPI tables" >> release_notes.md
        echo "- Documentation files" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Installation" >> release_notes.md
        echo "1. Download the appropriate package for your platform" >> release_notes.md
        echo "2. Extract the archive" >> release_notes.md
        echo "3. Follow the instructions in README.md" >> release_notes.md
        echo "" >> release_notes.md
        echo "For detailed usage instructions, see the [README](README.md) and [Debug Guide](DEBUG_GUIDE.md)." >> release_notes.md
    
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        name: ACPIPatcher ${{ github.ref_name }}
        body_path: release_notes.md
        files: release-assets/*
        draft: false
        prerelease: ${{ contains(github.ref_name, 'rc') || contains(github.ref_name, 'beta') || contains(github.ref_name, 'alpha') }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notification:
    name: Build Notification
    runs-on: ubuntu-latest
    needs: [build-linux, build-macos, build-windows, test-static-analysis]
    if: always()
    
    steps:
    - name: Determine Status
      id: status
      run: |
        if [[ "${{ needs.build-linux.result }}" == "success" && 
              "${{ needs.build-macos.result }}" == "success" && 
              "${{ needs.build-windows.result }}" == "success" ]]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "message=✅ All builds completed successfully" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=❌ One or more builds failed" >> $GITHUB_OUTPUT
        fi
    
    - name: Build Summary
      run: |
        echo "## Build Results Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Platform | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|---------|" >> $GITHUB_STEP_SUMMARY
        echo "| Linux (Ubuntu) | ${{ needs.build-linux.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| macOS | ${{ needs.build-macos.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Windows | ${{ needs.build-windows.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Static Analysis | ${{ needs.test-static-analysis.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Overall Status:** ${{ steps.status.outputs.message }}" >> $GITHUB_STEP_SUMMARY
