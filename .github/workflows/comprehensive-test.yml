name: Comprehensive Testing

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'ACPIPatcherPkg/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'ACPIPatcherPkg/**'
      - '.github/workflows/**'
  schedule:
    # Run nightly tests at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      test_level:
        description: 'Test Level'
        required: false
        default: 'standard'
        type: choice
        options:
          - 'basic'
          - 'standard'
          - 'comprehensive'
      enable_coverage:
        description: 'Enable Code Coverage'
        required: false
        default: false
        type: boolean

env:
  EDK2_VERSION: edk2-stable202405
  TEST_LEVEL: ${{ github.event.inputs.test_level || 'standard' }}

jobs:
  # Code Quality and Security Analysis
  security-analysis:
    name: Security & Quality Analysis
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Install Security Tools
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          cppcheck \
          clang-tools \
          flawfinder \
          rats \
          splint
    
    - name: Run Flawfinder (Security)
      run: |
        echo "üîç Running Flawfinder security analysis..."
        flawfinder --html --context --followdotdir ACPIPatcherPkg/ > flawfinder-report.html || true
        flawfinder --context ACPIPatcherPkg/ > flawfinder-report.txt || true
        
        # Show summary
        echo "Flawfinder Summary:"
        tail -10 flawfinder-report.txt || true
    
    - name: Run RATS (Security)
      run: |
        echo "üîç Running RATS security analysis..."
        rats -w 3 --html ACPIPatcherPkg/ > rats-report.html 2>/dev/null || true
        rats -w 3 ACPIPatcherPkg/ > rats-report.txt 2>/dev/null || true
        
        echo "RATS Analysis completed"
    
    - name: Advanced CPPCheck Analysis
      run: |
        echo "üîç Running comprehensive CPPCheck analysis..."
        cppcheck \
          --enable=all \
          --inconclusive \
          --force \
          --verbose \
          --template="{file}:{line}: {severity}: {message}" \
          --suppress=missingIncludeSystem \
          --suppress=unusedFunction \
          --suppress=ConfigurationNotChecked \
          --check-config \
          --xml --xml-version=2 \
          ACPIPatcherPkg/ 2> cppcheck-detailed.xml || true
        
        # Generate simple report
        if [ -s cppcheck-detailed.xml ]; then
          echo "üîç CPPCheck found potential issues:"
          grep -o 'msg="[^"]*"' cppcheck-detailed.xml | sed 's/msg="//g' | sed 's/"//g' | head -10 || true
        else
          echo "‚úÖ CPPCheck analysis passed - no issues found"
        fi
    
    - name: Clang Static Analyzer
      run: |
        echo "üîç Running Clang Static Analyzer..."
        # Create compile_commands.json simulation for clang-tidy
        find ACPIPatcherPkg -name "*.c" | head -10 | while read file; do
          echo "Analyzing: $file"
          clang-tidy "$file" -- -I./ACPIPatcherPkg/ACPIPatcher || true
        done
    
    - name: Check for Common Vulnerabilities
      run: |
        echo "üîç Checking for common vulnerability patterns..."
        
        # Check for unsafe functions
        echo "Checking for unsafe functions..."
        if grep -r "strcpy\|strcat\|sprintf\|gets\|scanf" ACPIPatcherPkg/ --include="*.c" --include="*.h"; then
          echo "‚ö†Ô∏è Found potentially unsafe functions"
        else
          echo "‚úÖ No unsafe functions found"
        fi
        
        # Check for buffer allocation patterns
        echo "Checking memory allocation patterns..."
        if grep -r "malloc\|calloc\|realloc" ACPIPatcherPkg/ --include="*.c" --include="*.h"; then
          echo "‚ÑπÔ∏è Found memory allocation - ensure proper cleanup"
        fi
        
        # Check for UEFI-specific patterns
        echo "Checking UEFI memory patterns..."
        grep -r "AllocatePool\|AllocatePages" ACPIPatcherPkg/ --include="*.c" --include="*.h" || true
    
    - name: Upload Security Reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-analysis-reports
        path: |
          flawfinder-report.*
          rats-report.*
          cppcheck-detailed.xml
        retention-days: 30

  # Build Matrix Testing
  build-matrix-test:
    name: Build Matrix (${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.build_type }})
    runs-on: ${{ matrix.runner }}
    
    strategy:
      fail-fast: false
      matrix:
        include:
          # Comprehensive Linux testing
          - platform: linux
            runner: ubuntu-latest
            arch: X64
            build_type: RELEASE
            toolchain: GCC5
            test_efi: true
          - platform: linux
            runner: ubuntu-latest
            arch: X64
            build_type: DEBUG
            toolchain: GCC5
            test_efi: true
          - platform: linux
            runner: ubuntu-latest
            arch: IA32
            build_type: RELEASE
            toolchain: GCC5
            test_efi: false
          - platform: linux
            runner: ubuntu-latest
            arch: IA32
            build_type: DEBUG
            toolchain: GCC5
            test_efi: false
          
          # macOS testing
          - platform: macos
            runner: macos-13
            arch: X64
            build_type: RELEASE
            toolchain: XCODE5
            test_efi: true
          - platform: macos
            runner: macos-13
            arch: X64
            build_type: DEBUG
            toolchain: XCODE5
            test_efi: true
          
          # Windows testing
          - platform: windows
            runner: windows-latest
            arch: X64
            build_type: RELEASE
            toolchain: VS2022
            test_efi: true
          - platform: windows
            runner: windows-latest
            arch: X64
            build_type: DEBUG
            toolchain: VS2022
            test_efi: true
          - platform: windows
            runner: windows-latest
            arch: IA32
            build_type: RELEASE
            toolchain: VS2022
            test_efi: false
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Build Environment (${{ matrix.platform }})
      run: |
        if [ "${{ matrix.platform }}" = "linux" ]; then
          sudo apt-get update
          sudo apt-get install -y build-essential nasm uuid-dev gcc-multilib file
          # Set compiler flags to work around EDK2 BaseTools issues
          export CFLAGS="-Wno-error=use-after-free -Wno-error=stringop-truncation"
          export CXXFLAGS="-Wno-error=use-after-free -Wno-error=stringop-truncation"
          echo "CFLAGS=$CFLAGS" >> $GITHUB_ENV
          echo "CXXFLAGS=$CXXFLAGS" >> $GITHUB_ENV
        elif [ "${{ matrix.platform }}" = "macos" ]; then
          brew install nasm mtoc
        fi
      shell: bash
    
    - name: Setup Build Environment (Windows)
      if: matrix.platform == 'windows'
      run: |
        choco install nasm -y
        
        # Show where Chocolatey installed NASM
        echo "Checking NASM installation locations..."
        Get-ChildItem "C:\ProgramData\chocolatey\lib\nasm" -Recurse -Filter "nasm.exe" -ErrorAction SilentlyContinue | Select-Object FullName
        
        # Find and add NASM to PATH for this session
        $possiblePaths = @(
          "C:\ProgramData\chocolatey\lib\nasm\tools",
          "C:\ProgramData\chocolatey\bin",
          "C:\tools\nasm",
          "C:\Program Files\NASM"
        )
        
        $nasmFound = $false
        foreach ($path in $possiblePaths) {
          if (Test-Path "$path\nasm.exe") {
            $env:PATH = "$path;$env:PATH"
            echo "Found and added NASM to PATH: $path"
            
            # Set GitHub environment variable to persist across steps
            echo "$path" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
            echo "Added to GITHUB_PATH: $path"
            $nasmFound = $true
            break
          }
        }
        
        if (-not $nasmFound) {
          echo "WARNING: NASM not found in standard locations"
          echo "Searching entire system for nasm.exe..."
          Get-ChildItem C:\ -Recurse -Filter "nasm.exe" -ErrorAction SilentlyContinue | Select-Object FullName
        }
        
        # Try to verify NASM installation
        try {
          nasm -v
          echo "‚úÖ NASM is accessible"
        } catch {
          echo "‚ö†Ô∏è NASM verification failed, but it may still work in build environment"
        }
    
    - name: Setup Visual Studio Environment (Windows)
      if: matrix.platform == 'windows'
      uses: microsoft/setup-msbuild@v1.3
      
    - name: Setup Windows Build Environment
      if: matrix.platform == 'windows'
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v3
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-${{ matrix.platform }}-${{ matrix.arch }}-test
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      shell: bash
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          git submodule update --init --recommend-shallow || echo "Warning: Some submodules failed to initialize"
        fi
    
    - name: Copy ACPIPatcher to EDK2 (Unix)
      if: matrix.platform != 'windows'
      run: |
        cp -r acpipatcher/ACPIPatcherPkg edk2/
      shell: bash
    
    - name: Copy ACPIPatcher to EDK2 (Windows)
      if: matrix.platform == 'windows'
      run: |
        xcopy /E /I acpipatcher\ACPIPatcherPkg edk2\ACPIPatcherPkg
    
    - name: Build ACPIPatcher (Unix)
      if: matrix.platform != 'windows'
      run: |
        cd edk2
        . edksetup.sh
        
        # Build BaseTools with error workarounds for older EDK2 versions
        echo "Building EDK2 BaseTools..."
        if ! make -C BaseTools CFLAGS="-Wno-error=use-after-free -Wno-error=stringop-truncation" 2>/dev/null; then
          echo "BaseTools build failed with strict flags, trying with relaxed flags..."
          make -C BaseTools CFLAGS="-w" || {
            echo "BaseTools build failed completely, trying alternative approach..."
            export CC="gcc -Wno-error"
            make -C BaseTools
          }
        fi
        
        echo "Building ACPIPatcher with ${{ matrix.toolchain }}..."
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t ${{ matrix.toolchain }} \
              -p ACPIPatcherPkg/ACPIPatcherPkg.dsc \
              -D DEBUG_LEVEL=3
    
    - name: Build ACPIPatcher (Windows)
      if: matrix.platform == 'windows'
      shell: cmd
      run: |
        cd edk2
        
        REM ====================================================================
        REM CRITICAL: Set up NASM PATH before any EDK2 operations
        REM ====================================================================
        echo Setting up NASM environment...
        
        REM Check multiple possible NASM installation locations
        if exist "C:\ProgramData\chocolatey\lib\nasm\tools\nasm.exe" (
          set "NASM_PREFIX=C:\ProgramData\chocolatey\lib\nasm\tools\"
          set "PATH=C:\ProgramData\chocolatey\lib\nasm\tools;%PATH%"
          echo ‚úÖ Found NASM at C:\ProgramData\chocolatey\lib\nasm\tools\
        ) else if exist "C:\ProgramData\chocolatey\bin\nasm.exe" (
          set "NASM_PREFIX=C:\ProgramData\chocolatey\bin\"
          set "PATH=C:\ProgramData\chocolatey\bin;%PATH%"
          echo ‚úÖ Found NASM at C:\ProgramData\chocolatey\bin\
        ) else if exist "C:\tools\nasm\nasm.exe" (
          set "NASM_PREFIX=C:\tools\nasm\"
          set "PATH=C:\tools\nasm;%PATH%"
          echo ‚úÖ Found NASM at C:\tools\nasm\
        ) else if exist "C:\Program Files\NASM\nasm.exe" (
          set "NASM_PREFIX=C:\Program Files\NASM\"
          set "PATH=C:\Program Files\NASM;%PATH%"
          echo ‚úÖ Found NASM at C:\Program Files\NASM\
        ) else (
          echo ‚ö†Ô∏è NASM not found in standard locations, setting default...
          set "NASM_PREFIX=C:\ProgramData\chocolatey\lib\nasm\tools\"
        )
        
        REM Verify NASM is accessible
        nasm -v >nul 2>&1
        if errorlevel 1 (
          echo ‚ùå NASM verification failed - this may cause build issues
          echo Searching for NASM in additional locations...
          where nasm 2>nul || echo NASM not found in PATH
        ) else (
          echo ‚úÖ NASM is accessible and ready
        )
        
        REM Set environment variables to avoid warnings
        echo Setting up environment variables...
        
        REM Set CLANG_BIN
        if exist "C:\Program Files\LLVM\bin\clang.exe" (
          set "CLANG_BIN=C:\Program Files\LLVM\bin\"
          echo Set CLANG_BIN=%CLANG_BIN%
        )
        
        REM Set CYGWIN_HOME to empty
        set "CYGWIN_HOME="
        echo Set CYGWIN_HOME to empty
        
        echo Building BaseTools for Windows...
        cd BaseTools
        python -m pip install --upgrade pip
        
        REM Use enhanced BaseTools build with warning suppression
        set CL=/W0
        set LINK=/IGNORE:4099
        echo Attempting BaseTools build with warning suppression...
        nmake >nul 2>&1
        if errorlevel 1 (
          echo Standard build failed, trying enhanced suppression...
          nmake clean >nul 2>&1
          set CFLAGS=/nologo /Z7 /c /O2 /MT /W0 /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE
          nmake CFLAGS="%CFLAGS%" >nul 2>&1
          if errorlevel 1 (
            echo Enhanced build failed, trying with patched makefiles...
            if exist "Makefiles\ms.common" (
              powershell -Command "(Get-Content 'Makefiles\ms.common') -replace '/W4 /WX', '/W0' | Set-Content 'Makefiles\ms.common'"
            )
            nmake
            if errorlevel 1 (
              echo All BaseTools build methods failed
              exit /b 1
            )
          )
        )
        
        REM Ensure Bin\Win32 directory exists and contains tools
        if not exist "Bin\Win32" (
          echo Creating missing Bin\Win32 directory...
          mkdir "Bin\Win32" 2>nul
          REM Copy tools from alternative locations if they exist
          if exist "Bin\*.exe" copy "Bin\*.exe" "Bin\Win32\" >nul 2>&1
          if exist "*.exe" copy "*.exe" "Bin\Win32\" >nul 2>&1
          for /d %%D in (Source\C\*) do (
            if exist "%%D\*.exe" copy "%%D\*.exe" "Bin\Win32\" >nul 2>&1
          )
        )
        
        echo BaseTools build completed successfully
        cd ..
        
        REM Re-establish environment variables before calling edksetup.bat
        echo Re-establishing environment variables before EDK2 setup...
        
        REM Re-set NASM_PREFIX
        where nasm >nul 2>&1
        if errorlevel 1 (
          if exist "%ProgramData%\chocolatey\bin\nasm.exe" (
            set "NASM_PREFIX=%ProgramData%\chocolatey\bin\"
            set "PATH=%ProgramData%\chocolatey\bin;%PATH%"
          ) else if exist "C:\tools\nasm\nasm.exe" (
            set "NASM_PREFIX=C:\tools\nasm\"
            set "PATH=C:\tools\nasm;%PATH%"
          ) else if exist "C:\Program Files\NASM\nasm.exe" (
            set "NASM_PREFIX=C:\Program Files\NASM\"
            set "PATH=C:\Program Files\NASM;%PATH%"
          ) else (
            set "NASM_PREFIX=C:\tools\nasm\"
          )
        ) else (
          for /f "tokens=*" %%i in ('where nasm') do (
            set "NASM_PATH=%%i"
            goto :found_nasm_comp2
          )
          :found_nasm_comp2
          for %%i in ("%NASM_PATH%") do set "NASM_PREFIX=%%~dpi"
        )
        echo Re-set NASM_PREFIX=%NASM_PREFIX%
        
        REM Re-set CLANG_BIN
        if exist "C:\Program Files\LLVM\bin\clang.exe" (
          set "CLANG_BIN=C:\Program Files\LLVM\bin\"
          echo Re-set CLANG_BIN=%CLANG_BIN%
        )
        
        REM Re-set CYGWIN_HOME
        set "CYGWIN_HOME="
        echo Re-set CYGWIN_HOME to empty
        
        REM Now call edksetup.bat after BaseTools are built
        echo Setting up EDK2 environment after BaseTools build...
        call edksetup.bat
        
        REM Ensure EDK_TOOLS_BIN is set
        if "%EDK_TOOLS_BIN%"=="" (
          set "EDK_TOOLS_BIN=%WORKSPACE%\BaseTools\Bin\Win32"
        )
        
        REM Reset CL for application build
        set CL=
        
        echo Building ACPIPatcher with VS2022...
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t VS2022 ^
              -p ACPIPatcherPkg\ACPIPatcherPkg.dsc ^
              -D DEBUG_LEVEL=3
    
    - name: Verify Build and Test EFI Files (Unix)
      if: matrix.platform != 'windows'
      run: |
        cd edk2
        
        echo "=== Dynamic Build Artifact Discovery ==="
        echo "Searching for .efi files in Build directory..."
        find Build/ -name "*.efi" 2>/dev/null || echo "No .efi files found"
        
        echo "=== Build Verification ==="
        EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
        DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
        
        # Check if binaries exist and get their info
        if [ -n "$EFI_PATH" ] && [ -f "$EFI_PATH" ]; then
          echo "‚úÖ ACPIPatcher.efi found: $EFI_PATH"
          ls -la "$EFI_PATH"
          file "$EFI_PATH" || true
        else
          echo "‚ùå ACPIPatcher.efi missing"
          exit 1
        fi
        
        if [ -n "$DXE_PATH" ] && [ -f "$DXE_PATH" ]; then
          echo "‚úÖ ACPIPatcherDxe.efi found: $DXE_PATH"
          ls -la "$DXE_PATH"
          file "$DXE_PATH" || true
        else
          echo "‚ùå ACPIPatcherDxe.efi missing"
          exit 1
        fi
      shell: bash
    
    - name: Verify Build and Test EFI Files (Windows)
      if: matrix.platform == 'windows'
      shell: powershell
      run: |
        cd edk2
        
        Write-Host "=== Dynamic Build Artifact Discovery ==="
        Write-Host "Searching for .efi files in Build directory..."
        $EfiFiles = Get-ChildItem -Path "Build" -Recurse -Filter "*.efi" -ErrorAction SilentlyContinue
        if ($EfiFiles) {
          foreach ($file in $EfiFiles) {
            Write-Host "Found EFI file: $($file.FullName)"
          }
        } else {
          Write-Host "No .efi files found"
        }
        
        Write-Host "=== Build Verification ==="
        $EFI_PATH = (Get-ChildItem -Path "Build" -Recurse -Filter "ACPIPatcher.efi" -ErrorAction SilentlyContinue | Select-Object -First 1).FullName
        $DXE_PATH = (Get-ChildItem -Path "Build" -Recurse -Filter "ACPIPatcherDxe.efi" -ErrorAction SilentlyContinue | Select-Object -First 1).FullName
        
        # Check if binaries exist and get their info
        if ($EFI_PATH -and (Test-Path $EFI_PATH)) {
          Write-Host "‚úÖ ACPIPatcher.efi found: $EFI_PATH"
          Get-ItemProperty $EFI_PATH | Select-Object Name, Length, LastWriteTime
        } else {
          Write-Host "‚ùå ACPIPatcher.efi missing"
          exit 1
        }
        
        if ($DXE_PATH -and (Test-Path $DXE_PATH)) {
          Write-Host "‚úÖ ACPIPatcherDxe.efi found: $DXE_PATH"
          Get-ItemProperty $DXE_PATH | Select-Object Name, Length, LastWriteTime
        } else {
          Write-Host "‚ùå ACPIPatcherDxe.efi missing"
          exit 1
        }
    
    - name: Extended EFI Testing
      if: matrix.test_efi && matrix.platform != 'windows'
      run: |
        cd edk2
        
        echo "=== Extended EFI File Analysis ==="
        EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
        
        if [ -n "$EFI_PATH" ] && [ -f "$EFI_PATH" ]; then
          echo "Analyzing EFI file structure for: $EFI_PATH"
          
          # Check EFI file headers and basic structure
          echo "Analyzing EFI file structure..."
          hexdump -C "$EFI_PATH" | head -5 || true
          
          # Check for common EFI signatures
          echo "Checking for EFI signatures..."
          if strings "$EFI_PATH" | grep -i "uefi\|efi" | head -5; then
            echo "‚úÖ Found EFI/UEFI signatures"
          else
            echo "‚ö†Ô∏è No obvious EFI signatures found"
          fi
          
          # Check file size (should be reasonable)
          SIZE=$(stat -c%s "$EFI_PATH" 2>/dev/null || stat -f%z "$EFI_PATH" 2>/dev/null || echo "0")
          echo "ACPIPatcher.efi size: $SIZE bytes"
          
          if [ "$SIZE" -gt 1000 ] && [ "$SIZE" -lt 10000000 ]; then
            echo "‚úÖ EFI file size is reasonable"
          else
            echo "‚ö†Ô∏è EFI file size seems unusual"
          fi
        else
          echo "‚ùå ACPIPatcher.efi not found for extended testing"
        fi
    
    - name: Create Test Package (Unix)
      if: matrix.platform != 'windows'
      run: |
        cd edk2
        
        echo "=== Creating Test Package with Dynamic Artifacts ==="
        EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
        DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
        
        PACKAGE_NAME="ACPIPatcher-Test-${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.build_type }}"
        
        mkdir "$PACKAGE_NAME"
        
        # Copy EFI files using dynamic paths
        if [ -n "$EFI_PATH" ] && [ -f "$EFI_PATH" ]; then
          cp "$EFI_PATH" "$PACKAGE_NAME/"
          echo "‚úÖ Packaged ACPIPatcher.efi from: $EFI_PATH"
        fi
        
        if [ -n "$DXE_PATH" ] && [ -f "$DXE_PATH" ]; then
          cp "$DXE_PATH" "$PACKAGE_NAME/"
          echo "‚úÖ Packaged ACPIPatcherDxe.efi from: $DXE_PATH"
        fi
        cp "$BUILD_DIR/ACPIPatcher.efi" "$PACKAGE_NAME/" 2>/dev/null || true
        cp "$BUILD_DIR/ACPIPatcherDxe.efi" "$PACKAGE_NAME/" 2>/dev/null || true
        
        # Create test report
        echo "Test Build Report" > "$PACKAGE_NAME/TEST_REPORT.txt"
        echo "Platform: ${{ matrix.platform }}" >> "$PACKAGE_NAME/TEST_REPORT.txt"
        echo "Architecture: ${{ matrix.arch }}" >> "$PACKAGE_NAME/TEST_REPORT.txt"
        echo "Build Type: ${{ matrix.build_type }}" >> "$PACKAGE_NAME/TEST_REPORT.txt"
        echo "Toolchain: ${{ matrix.toolchain }}" >> "$PACKAGE_NAME/TEST_REPORT.txt"
        echo "Test Date: $(date)" >> "$PACKAGE_NAME/TEST_REPORT.txt"
        echo "Test Level: ${{ env.TEST_LEVEL }}" >> "$PACKAGE_NAME/TEST_REPORT.txt"
      shell: bash
    
    - name: Create Test Package (Windows)
      if: matrix.platform == 'windows'
      shell: powershell
      run: |
        cd edk2
        $BUILD_DIR = "Build\ACPIPatcherPkg\${{ matrix.build_type }}_${{ matrix.toolchain }}\${{ matrix.arch }}"
        $PACKAGE_NAME = "ACPIPatcher-Test-${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.build_type }}"
        
        New-Item -ItemType Directory -Path "$PACKAGE_NAME" -Force
        if (Test-Path "$BUILD_DIR\ACPIPatcher.efi") {
          Copy-Item "$BUILD_DIR\ACPIPatcher.efi" "$PACKAGE_NAME\"
        }
        if (Test-Path "$BUILD_DIR\ACPIPatcherDxe.efi") {
          Copy-Item "$BUILD_DIR\ACPIPatcherDxe.efi" "$PACKAGE_NAME\"
        }
        
        # Create test report
        $testReport = "Test Build Report`n"
        $testReport += "Platform: ${{ matrix.platform }}`n"
        $testReport += "Architecture: ${{ matrix.arch }}`n"
        $testReport += "Build Type: ${{ matrix.build_type }}`n"
        $testReport += "Toolchain: ${{ matrix.toolchain }}`n"
        $testReport += "Test Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')`n"
        $testReport += "Test Level: ${{ env.TEST_LEVEL }}`n"
        
        $testReport | Out-File -FilePath "$PACKAGE_NAME\TEST_REPORT.txt" -Encoding UTF8
    
    - name: Upload Test Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: test-build-${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.build_type }}
        path: edk2/ACPIPatcher-Test-*
        retention-days: 7

  # Documentation and Validation Tests
  documentation-validation:
    name: Documentation Validation
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Validate README Structure
      run: |
        echo "üîç Validating README.md structure..."
        
        # Check for required sections
        REQUIRED_SECTIONS=(
          "## Features"
          "## Quick Start"
          "## Usage"
          "## Build Instructions"
          "## System Requirements"
        )
        
        for section in "${REQUIRED_SECTIONS[@]}"; do
          if grep -q "$section" README.md; then
            echo "‚úÖ Found: $section"
          else
            echo "‚ùå Missing: $section"
          fi
        done
    
    - name: Check Documentation Links
      run: |
        echo "üîç Checking documentation links..."
        
        # Extract markdown links
        grep -oE '\[([^\]]+)\]\(([^)]+)\)' README.md | while read link; do
          echo "Found link: $link"
        done
        
        # Check for broken internal links
        grep -oE '\[([^\]]+)\]\(([^)]+)\)' README.md | grep -E '\.(md|txt)' | while read link; do
          file=$(echo "$link" | sed 's/.*(\([^)]*\)).*/\1/')
          if [ -f "$file" ]; then
            echo "‚úÖ Valid internal link: $file"
          else
            echo "‚ùå Broken internal link: $file"
          fi
        done
    
    - name: Validate Code Examples
      run: |
        echo "üîç Validating code examples in documentation..."
        
        # Check if code blocks are properly formatted
        if grep -E '^```[a-z]*$' README.md >/dev/null; then
          echo "‚úÖ Found properly formatted code blocks"
        else
          echo "‚ö†Ô∏è No code blocks found or improperly formatted"
        fi
        
        # Count code blocks
        CODE_BLOCKS=$(grep -c '^```' README.md || echo "0")
        echo "Found $CODE_BLOCKS code block markers"
        
        if [ $((CODE_BLOCKS % 2)) -eq 0 ]; then
          echo "‚úÖ Code blocks are properly closed"
        else
          echo "‚ùå Unmatched code block markers"
        fi

  # Integration and Compatibility Tests  
  compatibility-test:
    name: Compatibility Testing
    runs-on: ubuntu-latest
    needs: [build-matrix-test]
    if: github.event.inputs.test_level == 'comprehensive' || github.event_name == 'schedule'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Download Build Artifacts
      uses: actions/download-artifact@v3
      with:
        path: test-artifacts
    
    - name: Compatibility Analysis
      run: |
        echo "üîç Running compatibility analysis..."
        
        echo "=== Artifact Summary ==="
        find test-artifacts -name "*.efi" | while read efi_file; do
          echo "Found EFI: $efi_file"
          ls -la "$efi_file"
          
          # Basic EFI validation
          if file "$efi_file" | grep -i "PE32\|executable"; then
            echo "‚úÖ Valid PE32 executable format"
          else
            echo "‚ö†Ô∏è Unexpected file format"
          fi
          
          # Check file size consistency
          SIZE=$(stat -c%s "$efi_file")
          echo "Size: $SIZE bytes"
          
          # Extract platform info from path
          PLATFORM=$(echo "$efi_file" | grep -oE "(linux|macos|windows)")
          ARCH=$(echo "$efi_file" | grep -oE "(X64|IA32)")
          echo "Platform: $PLATFORM, Architecture: $ARCH"
          echo "---"
        done
    
    - name: Cross-Platform Consistency Check
      run: |
        echo "üîç Checking cross-platform consistency..."
        
        # Check if we have builds for all expected platforms
        PLATFORMS=$(find test-artifacts -name "*.efi" | grep -oE "(linux|macos|windows)" | sort -u)
        echo "Available platforms: $PLATFORMS"
        
        ARCHITECTURES=$(find test-artifacts -name "*.efi" | grep -oE "(X64|IA32)" | sort -u)
        echo "Available architectures: $ARCHITECTURES"
        
        # Count builds per platform
        for platform in $PLATFORMS; do
          COUNT=$(find test-artifacts -name "*.efi" | grep "$platform" | wc -l)
          echo "Platform $platform: $COUNT builds"
        done

  # Performance and Resource Tests
  performance-test:
    name: Performance Testing
    runs-on: ubuntu-latest
    needs: [build-matrix-test]
    if: github.event.inputs.test_level == 'comprehensive' || github.event_name == 'schedule'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Code Complexity Analysis
      run: |
        echo "üîç Analyzing code complexity..."
        
        # Count lines of code
        echo "=== Code Statistics ==="
        find ACPIPatcherPkg -name "*.c" -o -name "*.h" | xargs wc -l | tail -1
        
        # Function complexity (approximate)
        echo "=== Function Analysis ==="
        grep -r "^[A-Za-z_][A-Za-z0-9_]* *(" ACPIPatcherPkg/ --include="*.c" | wc -l | xargs echo "Approximate function count:"
        
        # Check for large functions (potential complexity issues)
        echo "=== Large Function Detection ==="
        find ACPIPatcherPkg -name "*.c" | while read file; do
          awk '/^[A-Za-z_][A-Za-z0-9_]* *\(/{func=$0; lines=1} /^}$/{if(lines>50) print func " in " FILENAME " (" lines " lines)"; lines=0} !/^[A-Za-z_][A-Za-z0-9_]* *\(/{if(lines>0) lines++}' "$file"
        done
    
    - name: Memory Usage Analysis
      run: |
        echo "üîç Analyzing memory usage patterns..."
        
        # Check for memory allocation calls
        echo "=== Memory Allocation Patterns ==="
        grep -r "AllocatePool\|AllocatePages\|AllocateZeroPool" ACPIPatcherPkg/ --include="*.c" | wc -l | xargs echo "Memory allocation calls:"
        
        # Check for memory deallocation calls
        grep -r "FreePool\|FreePages" ACPIPatcherPkg/ --include="*.c" | wc -l | xargs echo "Memory deallocation calls:"
        
        # Look for potential memory leaks (allocations without corresponding frees)
        echo "=== Potential Memory Management Issues ==="
        ALLOC_COUNT=$(grep -r "AllocatePool\|AllocatePages\|AllocateZeroPool" ACPIPatcherPkg/ --include="*.c" | wc -l)
        FREE_COUNT=$(grep -r "FreePool\|FreePages" ACPIPatcherPkg/ --include="*.c" | wc -l)
        
        echo "Allocation calls: $ALLOC_COUNT"
        echo "Deallocation calls: $FREE_COUNT"
        
        if [ "$ALLOC_COUNT" -gt "$FREE_COUNT" ]; then
          echo "‚ö†Ô∏è More allocations than deallocations - check for memory leaks"
        elif [ "$FREE_COUNT" -gt "$ALLOC_COUNT" ]; then
          echo "‚ö†Ô∏è More deallocations than allocations - check for double-free issues"
        else
          echo "‚úÖ Allocation/deallocation count balanced"
        fi

  # Summary and Reporting
  test-summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs: [security-analysis, build-matrix-test, documentation-validation, compatibility-test, performance-test]
    if: always()
    
    steps:
    - name: Generate Test Report
      run: |
        echo "# Comprehensive Test Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## Test Results Overview" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Test Category | Status | Details |" >> $GITHUB_STEP_SUMMARY
        echo "|---------------|---------|---------|" >> $GITHUB_STEP_SUMMARY
        echo "| Security Analysis | ${{ needs.security-analysis.result == 'success' && '‚úÖ Passed' || needs.security-analysis.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} | Static security analysis with multiple tools |" >> $GITHUB_STEP_SUMMARY
        echo "| Build Matrix | ${{ needs.build-matrix-test.result == 'success' && '‚úÖ Passed' || needs.build-matrix-test.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} | Multi-platform build testing |" >> $GITHUB_STEP_SUMMARY
        echo "| Documentation | ${{ needs.documentation-validation.result == 'success' && '‚úÖ Passed' || needs.documentation-validation.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} | Documentation structure and link validation |" >> $GITHUB_STEP_SUMMARY
        echo "| Compatibility | ${{ needs.compatibility-test.result == 'success' && '‚úÖ Passed' || needs.compatibility-test.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} | Cross-platform compatibility analysis |" >> $GITHUB_STEP_SUMMARY
        echo "| Performance | ${{ needs.performance-test.result == 'success' && '‚úÖ Passed' || needs.performance-test.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} | Code complexity and performance analysis |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Overall status
        if [[ "${{ needs.security-analysis.result }}" == "success" && 
              "${{ needs.build-matrix-test.result }}" == "success" && 
              "${{ needs.documentation-validation.result }}" == "success" ]]; then
          echo "## ‚úÖ Overall Status: PASSED" >> $GITHUB_STEP_SUMMARY
          echo "All critical tests completed successfully." >> $GITHUB_STEP_SUMMARY
        else
          echo "## ‚ùå Overall Status: FAILED" >> $GITHUB_STEP_SUMMARY
          echo "One or more critical tests failed. Please review the results above." >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## Test Configuration" >> $GITHUB_STEP_SUMMARY
        echo "- **Test Level:** ${{ env.TEST_LEVEL }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
    
    - name: Determine Final Status
      run: |
        if [[ "${{ needs.security-analysis.result }}" == "success" && 
              "${{ needs.build-matrix-test.result }}" == "success" && 
              "${{ needs.documentation-validation.result }}" == "success" ]]; then
          echo "üéâ All critical tests passed!"
          exit 0
        else
          echo "‚ùå One or more critical tests failed"
          exit 1
        fi
