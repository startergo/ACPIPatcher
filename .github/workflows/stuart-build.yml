name: ACPIPatcher Stuart Build System (GCC5/MinGW)

on:
  workflow_dispatch:

env:
  EDK2_VERSION: edk2-stable202405

jobs:
  stuart-build:
    name: Stuart Build (${{ matrix.os }}, ${{ matrix.arch }}, ${{ matrix.build_type }})
    runs-on: ${{ matrix.runner }}
    
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows builds with GCC5/MinGW using MSYS2
          - os: windows
            runner: windows-latest
            arch: X64
            build_type: RELEASE
            toolchain: GCC5
            msys: mingw64
            msys_env: x86_64
          - os: windows
            runner: windows-latest
            arch: IA32
            build_type: RELEASE
            toolchain: GCC5
            msys: mingw32
            msys_env: i686
          - os: windows
            runner: windows-latest
            arch: X64
            build_type: DEBUG
            toolchain: GCC5
            msys: mingw64
            msys_env: x86_64
          - os: windows
            runner: windows-latest
            arch: IA32
            build_type: DEBUG
            toolchain: GCC5
            msys: mingw32
            msys_env: i686
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher

    - name: Setup MSYS2 for MinGW (Base packages)
      uses: msys2/setup-msys2@v2
      with:
        msystem: ${{ matrix.msys }}
        update: true
        install: >-
          git
          python3
          python3-pip
          mingw-w64-${{ matrix.msys_env }}-gcc
          mingw-w64-${{ matrix.msys_env }}-python
          mingw-w64-${{ matrix.msys_env }}-python-pip
          mingw-w64-${{ matrix.msys_env }}-python-setuptools
          mingw-w64-${{ matrix.msys_env }}-python-wheel
          mingw-w64-${{ matrix.msys_env }}-python-build
          mingw-w64-${{ matrix.msys_env }}-python-installer
          mingw-w64-${{ matrix.msys_env }}-rust
          mingw-w64-${{ matrix.msys_env }}-pkgconf
          mingw-w64-${{ matrix.msys_env }}-pkg-config
          mingw-w64-${{ matrix.msys_env }}-libffi
          mingw-w64-${{ matrix.msys_env }}-make
          mingw-w64-${{ matrix.msys_env }}-openssl
          mingw-w64-${{ matrix.msys_env }}-cc
          base-devel

    - name: Install additional MSYS2 packages for x64 builds only
      if: matrix.arch == 'X64'
      uses: msys2/setup-msys2@v2
      with:
        msystem: ${{ matrix.msys }}
        update: false
        install: >-
          mingw-w64-x86_64-python-cryptography
          mingw-w64-x86_64-python-maturin

    # Note: python-cffi is only available in UCRT variant (mingw-w64-ucrt-x86_64-python-cffi)
    # However, UCRT cffi has dependencies on UCRT Python/libffi which conflicts with regular MinGW
    # UCRT cffi dependencies: mingw-w64-ucrt-x86_64-python, mingw-w64-ucrt-x86_64-libffi
    # We use regular MinGW: mingw-w64-x86_64-python, mingw-w64-x86_64-libffi
    # IA32 builds have no MSYS2 packages for python-cryptography, python-cffi, or python-maturin
    # cffi will be installed via PowerShell into the MSYS2 virtual environment to avoid compilation issues

    # Clone and setup EDK2
    - name: Clone EDK2 Repository
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git

    - name: Verify System Python Environment (GCC5 Toolchain)
      shell: msys2 {0}
      run: |
        cd edk2
        
        # CRITICAL: Remove any existing virtual environment to force system Python usage
        if [ -d ".venv" ]; then
          echo "Removing existing virtual environment to force system Python usage..."
          rm -rf .venv
        fi
        
        echo "Verifying system Python environment for GCC5/MinGW..."
        echo "Using system Python directly to avoid virtual environment conflicts"
        echo "MSYS2 Python has all required packages pre-installed"
        
        # Verify that MSYS2 packages are accessible
        echo "Checking access to MSYS2 packages..."
        if python3 -c "import cffi; print(f'cffi version: {cffi.__version__}')" 2>/dev/null; then
          echo "✅ cffi accessible"
        else
          echo "⚠️ cffi not accessible"
        fi
        
        if python3 -c "import cryptography; print(f'cryptography version: {cryptography.__version__}')" 2>/dev/null; then
          echo "✅ cryptography accessible"
        else
          echo "⚠️ cryptography not accessible"
        fi
        
        if python3 -c "import importlib.util; print('importlib.util is available')" 2>/dev/null; then
          echo "✅ importlib.util accessible"
        else
          echo "❌ importlib.util not accessible - this will cause plugin loading issues"
        fi
        
        echo "✅ System Python environment verified for MSYS2 packages"

    - name: Install build tools and dependencies (system Python)
      shell: msys2 {0}
      run: |
        cd edk2
        
        echo "Installing build tools and dependencies using system Python..."
        echo "Using MSYS2 system Python to avoid virtual environment conflicts"
        
        # Set up proper MinGW environment for any compilation needs
        export PATH="/mingw64/bin:$PATH"
        export PKG_CONFIG_PATH="/mingw64/lib/pkgconfig:$PKG_CONFIG_PATH"
        export LIBFFI_DIR="/mingw64"
        export CFLAGS="-I/mingw64/include"
        export LDFLAGS="-L/mingw64/lib"
        
        echo "MinGW environment configured"
        
        # Upgrade core packages in system Python
        echo "Upgrading core packages in system Python..."
        for package in "pip" "setuptools" "wheel" "build"; do
          echo "Upgrading $package..."
          if python3 -m pip install --upgrade --user "$package" 2>/dev/null; then
            echo "✅ Successfully upgraded $package"
          else
            echo "⚠️ Warning: Failed to upgrade $package"
          fi
        done
        
        echo "✅ Build tools and dependencies installation completed"
        echo "Final package availability check:"
        for package in "cffi" "cryptography" "maturin" "setuptools" "wheel" "build"; do
          if python3 -c "import $package" 2>/dev/null; then
            echo "  ✅ $package: Available"
          else
            echo "  ❌ $package: Not available"
          fi
        done

    - name: Install Stuart and handle remaining dependencies (System Python)
      shell: msys2 {0}
      run: |
        cd edk2
        
        echo "Installing Stuart build system using system Python..."
        echo "This avoids virtual environment isolation issues with importlib.util"
        
        # Install Stuart build system directly to system Python user directory
        echo "Installing Stuart to system Python user directory..."
        if python3 -m pip install --user --upgrade edk2-pytool-extensions edk2-pytool-library 2>&1; then
          echo "✅ Successfully installed Stuart build system"
        else
          echo "❌ Stuart installation failed"
          exit 1
        fi
        
        # Verify Stuart commands are available
        echo "Verifying Stuart commands are available..."
        if command -v stuart_update >/dev/null 2>&1; then
          echo "  ✅ stuart_update command available"
        else
          echo "  ⚠️ stuart_update command not found in PATH"
          echo "  Adding Python user bin to PATH..."
          export PATH="$HOME/.local/bin:$PATH"
          if command -v stuart_update >/dev/null 2>&1; then
            echo "  ✅ stuart_update command now available"
          else
            echo "  ❌ stuart_update still not found"
          fi
        fi
        
        if command -v stuart_ci_build >/dev/null 2>&1; then
          echo "  ✅ stuart_ci_build command available"
        else
          echo "  ⚠️ stuart_ci_build command not found in PATH"
        fi
        
        echo "✅ Stuart installation completed"

    - name: Copy ACPIPatcher to EDK2
      shell: pwsh
      run: |
        # Copy ACPIPatcher package
        Copy-Item -Recurse acpipatcher/ACPIPatcherPkg edk2/ -Force
        Write-Host "✅ Copied ACPIPatcherPkg to EDK2"
        
        # Copy Stuart configuration (overwrite if exists)
        if (Test-Path "acpipatcher/.pytool") {
          if (Test-Path "edk2/.pytool") {
            Remove-Item -Recurse -Force edk2/.pytool
            Write-Host "Removed existing .pytool directory"
          }
          Copy-Item -Recurse acpipatcher/.pytool edk2/
          Write-Host "✅ Copied Stuart configuration"
        } else {
          Write-Host "⚠️ No .pytool directory found in ACPIPatcher source"
        }
        
        # Copy pip requirements (overwrite if exists)
        if (Test-Path "acpipatcher/pip-requirements.txt") {
          Copy-Item acpipatcher/pip-requirements.txt edk2/ -Force
          Write-Host "✅ Copied pip requirements"
        } else {
          Write-Host "⚠️ No pip-requirements.txt found in ACPIPatcher source"
        }

    - name: Initialize EDK2 Submodules
      shell: pwsh
      run: |
        cd edk2
        
        # Configure git for better compatibility
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Initialize essential submodules only
        Write-Host "Initializing essential EDK2 submodules..."
        git submodule update --init --recommend-shallow BaseTools/Source/C/BrotliCompress/brotli CryptoPkg/Library/OpensslLib/openssl MdeModulePkg/Library/BrotliCustomDecompressLib/brotli UnitTestFrameworkPkg/Library/CmockaLib/cmocka
        
        Write-Host "✅ Submodule initialization completed"

    - name: Build BaseTools First (GCC5/MinGW Only)
      shell: msys2 {0}
      run: |
        cd edk2
        
        # CRITICAL: Remove any existing virtual environment to force system Python usage
        if [ -d ".venv" ]; then
          echo "Removing existing virtual environment to force system Python usage..."
          rm -rf .venv
        fi
        
        # Use system Python directly to avoid virtual environment isolation issues
        echo "Building BaseTools for GCC5 toolchain using system Python..."
        echo "This must be done BEFORE Stuart update to provide core EDK2 build infrastructure..."
        echo "Using system Python to avoid importlib.util isolation issues in virtual environment"
        
        # Diagnose Python environment before building BaseTools
        echo "=== Python Environment Diagnostics ==="
        echo "System Python executable: $(which python3)"
        echo "System Python version: $(python3 --version)"
        echo "System Python sys.path:"
        python3 -c "import sys; [print(f'  {p}') for p in sys.path]"
        
        # Check for importlib.util specifically (this was causing the failure)
        echo "Checking for importlib.util module in system Python..."
        if python3 -c "import importlib.util; print('importlib.util is available')" 2>/dev/null; then
          echo "✅ importlib.util module is available in system Python"
        else
          echo "❌ importlib.util module is NOT available in system Python"
          echo "This indicates a fundamental Python installation issue"
          exit 1
        fi
        
        # Check for other common standard library modules in system Python
        echo "Checking other standard library modules in system Python..."
        for module in "os" "sys" "pathlib" "subprocess" "json" "configparser"; do
          if python3 -c "import $module" 2>/dev/null; then
            echo "  ✅ $module: Available"
          else
            echo "  ❌ $module: Missing"
          fi
        done
        
        echo "=== Attempting BaseTools Build ==="
        
        # Try building BaseTools with enhanced error handling
        BASETOOLS_BUILD_SUCCESS=false
        
        # Attempt 1: Standard build
        echo "Attempt 1: Standard BaseTools build..."
        if python3 BaseTools/Edk2ToolsBuild.py -t GCC5 2>&1; then
          echo "✅ BaseTools build completed successfully (standard)"
          BASETOOLS_BUILD_SUCCESS=true
        else
          echo "⚠️ Standard BaseTools build failed"
        fi
        
        # Attempt 2: Try with explicit Python path if first attempt failed
        if [ "$BASETOOLS_BUILD_SUCCESS" = "false" ]; then
          echo "Attempt 2: BaseTools build with explicit Python configuration..."
          export PYTHON_COMMAND=$(which python3)
          export PYTHONPATH="$PYTHONPATH:$(python3 -c 'import sys; print(":".join(sys.path))')"
          
          if python3 BaseTools/Edk2ToolsBuild.py -t GCC5 2>&1; then
            echo "✅ BaseTools build completed successfully (explicit Python)"
            BASETOOLS_BUILD_SUCCESS=true
          else
            echo "⚠️ BaseTools build with explicit Python failed"
          fi
        fi
        
        # Attempt 3: Try building without plugins that are failing
        if [ "$BASETOOLS_BUILD_SUCCESS" = "false" ]; then
          echo "Attempt 3: BaseTools build without problematic plugins..."
          
          # Temporarily rename the problematic plugins to disable them
          if [ -f "BaseTools/Plugin/BuildToolsReport/BuildToolsReportGenerator.py" ]; then
            mv "BaseTools/Plugin/BuildToolsReport/BuildToolsReportGenerator.py" "BaseTools/Plugin/BuildToolsReport/BuildToolsReportGenerator.py.disabled" 2>/dev/null || true
          fi
          if [ -f "BaseTools/Plugin/DebugMacroCheck/BuildPlugin/DebugMacroCheckBuildPlugin.py" ]; then
            mv "BaseTools/Plugin/DebugMacroCheck/BuildPlugin/DebugMacroCheckBuildPlugin.py" "BaseTools/Plugin/DebugMacroCheck/BuildPlugin/DebugMacroCheckBuildPlugin.py.disabled" 2>/dev/null || true
          fi
          
          if python3 BaseTools/Edk2ToolsBuild.py -t GCC5 2>&1; then
            echo "✅ BaseTools build completed successfully (without problematic plugins)"
            BASETOOLS_BUILD_SUCCESS=true
          else
            echo "⚠️ BaseTools build without problematic plugins failed"
          fi
          
          # Restore the plugins
          if [ -f "BaseTools/Plugin/BuildToolsReport/BuildToolsReportGenerator.py.disabled" ]; then
            mv "BaseTools/Plugin/BuildToolsReport/BuildToolsReportGenerator.py.disabled" "BaseTools/Plugin/BuildToolsReport/BuildToolsReportGenerator.py" 2>/dev/null || true
          fi
          if [ -f "BaseTools/Plugin/DebugMacroCheck/BuildPlugin/DebugMacroCheckBuildPlugin.py.disabled" ]; then
            mv "BaseTools/Plugin/DebugMacroCheck/BuildPlugin/DebugMacroCheckBuildPlugin.py.disabled" "BaseTools/Plugin/DebugMacroCheck/BuildPlugin/DebugMacroCheckBuildPlugin.py" 2>/dev/null || true
          fi
        fi
        
        # Attempt 4: Use make directly with header conflict fix if Python build fails
        if [ "$BASETOOLS_BUILD_SUCCESS" = "false" ]; then
          echo "Attempt 4: Building BaseTools using make directly with header conflict detection..."
          cd BaseTools
          
          # Build with comprehensive error detection and header conflict fixing
          if make -C Source/C 2>&1 | tee ../basetools_make.log; then
            echo "✅ BaseTools built successfully using make"
            BASETOOLS_BUILD_SUCCESS=true
          else
            echo "❌ Make-based BaseTools build failed"
            echo "Analyzing build failure..."
            
            # Check for MinGW header conflicts (known issue)
            if grep -q "_filelength" ../basetools_make.log; then
              echo "❌ Detected _filelength MinGW header conflict"
              echo "This is a known issue where EDK2's CommonLib.h conflicts with MSYS2's io.h"
              echo "Attempting to patch the header conflict..."
              
              # Look for the problematic header file
              conflict_file="Source/C/Include/Common/BaseTypes.h"
              if [ -f "$conflict_file" ]; then
                echo "Found BaseTypes.h, checking for _filelength declaration..."
                if grep -q "_filelength" "$conflict_file"; then
                  echo "Creating backup and patching _filelength conflict..."
                  cp "$conflict_file" "${conflict_file}.backup"
                  
                  # Comment out the conflicting _filelength declaration
                  sed -i 's/^.*_filelength.*$/\/\/ &/' "$conflict_file" || true
                  echo "Patched _filelength declaration in $conflict_file"
                  
                  # Retry build after patching
                  echo "Retrying BaseTools build after header patch..."
                  if make clean && make -C Source/C; then
                    echo "✅ BaseTools build succeeded after header patch"
                    BASETOOLS_BUILD_SUCCESS=true
                  else
                    echo "❌ BaseTools build still failed after header patch"
                    # Restore original file
                    if [ -f "${conflict_file}.backup" ]; then
                      mv "${conflict_file}.backup" "$conflict_file"
                    fi
                  fi
                else
                  echo "No _filelength declaration found in $conflict_file"
                fi
              else
                echo "BaseTypes.h not found at expected location"
                echo "Looking for alternative conflict locations..."
                find Source/C -name "*.h" -exec grep -l "_filelength" {} \; 2>/dev/null || echo "No files with _filelength found"
              fi
            fi
            
            # Check for other common build issues
            if grep -q "No such file or directory" ../basetools_make.log; then
              echo "❌ Missing file/directory error detected"
              grep "No such file or directory" ../basetools_make.log | head -5
            fi
            
            if grep -q "undefined reference" ../basetools_make.log; then
              echo "❌ Undefined reference error detected"
              grep "undefined reference" ../basetools_make.log | head -5
            fi
          fi
          cd ..
        fi
        
        # Final result
        if [ "$BASETOOLS_BUILD_SUCCESS" = "false" ]; then
          echo "❌ All BaseTools build attempts failed"
          echo "This indicates a fundamental issue with the Python environment or BaseTools"
          echo "Common causes:"
          echo "  - Corrupted Python standard library (missing importlib.util)"
          echo "  - Virtual environment isolation issues"
          echo "  - MSYS2 Python package conflicts"
          echo "  - Missing development tools"
          echo ""
          echo "Continuing anyway - Stuart may be able to use system tools"
          echo "Some functionality may be limited without BaseTools"
        else
          echo "✅ BaseTools build completed successfully"
          
          # Verify BaseTools are working
          echo "Verifying BaseTools functionality..."
          if [ -f "BaseTools/Source/C/bin/GenFfs" ] || [ -f "BaseTools/BinWrappers/PosixLike/GenFfs" ]; then
            echo "  ✅ BaseTools binaries found"
          else
            echo "  ⚠️ BaseTools binaries not found in expected locations"
          fi
        fi

    - name: Stuart Update Dependencies (GCC5 Toolchain)
      shell: msys2 {0}
      run: |
        cd edk2
        
        # CRITICAL: Ensure no virtual environment exists
        if [ -d ".venv" ]; then
          echo "Removing virtual environment to force system Python usage..."
          rm -rf .venv
        fi
        
        # Use system Python directly instead of virtual environment
        echo "Running Stuart update using system Python to avoid isolation issues..."
        echo "This may take a while as binaries can be very large..."
        echo "BaseTools have been built, so Stuart should have better dependency resolution..."
        
        # Set PYTHON_COMMAND to use system Python
        export PYTHON_COMMAND=python3
        
        # Ensure stuart commands are in PATH
        export PATH="$HOME/.local/bin:$PATH"
        
        # Run stuart_update with architecture and toolchain specification
        # Add retry logic for Windows path issues
        STUART_UPDATE_SUCCESS=false
        for attempt in 1 2 3; do
          echo "Stuart update attempt $attempt of 3..."
          
          if stuart_update -c .pytool/CISettings.py -a ${{ matrix.arch }} -t ${{ matrix.build_type }} TOOL_CHAIN_TAG=${{ matrix.toolchain }}; then
            echo "✅ Stuart update completed successfully on attempt $attempt"
            STUART_UPDATE_SUCCESS=true
            break
          else
            echo "⚠️ Stuart update attempt $attempt failed"
            if [ $attempt -lt 3 ]; then
              echo "Cleaning up and retrying..."
              # Clean up any partial downloads that might be causing path issues
              find BaseTools/Bin -name "*extdep*" -type d -exec rm -rf {} \; 2>/dev/null || true
              sleep 5
            fi
          fi
        done
        
        if [ "$STUART_UPDATE_SUCCESS" = "false" ]; then
          echo "❌ All Stuart update attempts failed"
          echo "This may be due to Windows path length limitations or external dependency issues"
          echo "Continuing with available tools - some external binaries may not be available"
          echo "but the core build should still work with system-provided tools"
        else
          echo "✅ Stuart update completed successfully"
        fi

    - name: Stuart Build (GCC5 Toolchain)
      shell: msys2 {0}
      run: |
        cd edk2
        
        # CRITICAL: Ensure no virtual environment exists
        if [ -d ".venv" ]; then
          echo "Removing virtual environment to force system Python usage..."
          rm -rf .venv
        fi
        
        # Use system Python directly instead of virtual environment
        echo "Running Stuart build using system Python to compile EFI binaries..."
        echo "Note: Using stuart_build as the primary build command for actual compilation"
        echo "stuart_ci_build is for validation only, not for generating binaries"
        
        # Set PYTHON_COMMAND to use system Python
        export PYTHON_COMMAND=python3
        
        # Ensure stuart commands are in PATH
        export PATH="$HOME/.local/bin:$PATH"
        
        # Use stuart_build as the primary build command for actual compilation
        # stuart_ci_build is only for validation/testing, not for generating EFI files
        echo "Running stuart_build to generate EFI binaries..."
        stuart_build -c .pytool/CISettings.py -p ACPIPatcherPkg -a ${{ matrix.arch }} -t ${{ matrix.build_type }} TOOL_CHAIN_TAG=${{ matrix.toolchain }}
        
        if [ $? -eq 0 ]; then
          echo "✅ Stuart build completed successfully"
        else
          echo "❌ Stuart build failed - trying fallback to stuart_ci_build"
          echo "Note: Some Stuart versions may only have stuart_ci_build available"
          
          stuart_ci_build -c .pytool/CISettings.py -p ACPIPatcherPkg -a ${{ matrix.arch }} -t ${{ matrix.build_type }} TOOL_CHAIN_TAG=${{ matrix.toolchain }}
          
          if [ $? -eq 0 ]; then
            echo "✅ Stuart CI build completed successfully (fallback)"
          else
            echo "❌ Both stuart_build and stuart_ci_build failed"
            exit 1
          fi
        fi

    - name: Verify Build Output
      shell: bash
      run: |
        cd edk2
        
        echo "=== Build Verification ==="
        echo "Searching for built EFI files..."
        
        # Find all EFI files
        find Build/ -name "*.efi" 2>/dev/null || echo "No EFI files found"
        
        # Specifically look for ACPIPatcher binaries
        EFI_FILES=$(find Build/ -name "ACPIPatcher*.efi" 2>/dev/null)
        
        if [ -n "$EFI_FILES" ]; then
          echo "✅ Found ACPIPatcher binaries:"
          for file in $EFI_FILES; do
            echo "  - $file"
            ls -la "$file"
          done
        else
          echo "❌ No ACPIPatcher EFI files found"
          echo "Complete build directory structure:"
          find Build/ -type f 2>/dev/null | head -20
        fi

    - name: Create Distribution Package
      shell: bash
      run: |
        cd edk2
        
        # Create distribution directory
        DIST_DIR="ACPIPatcher-Stuart-${{ matrix.build_type }}-${{ matrix.arch }}-${{ matrix.os }}"
        mkdir -p "$DIST_DIR"
        
        # Copy all EFI files
        find Build/ -name "*.efi" -exec cp {} "$DIST_DIR/" \; 2>/dev/null || true
        
        # Copy documentation
        if [ -f "../acpipatcher/README.md" ]; then
          cp ../acpipatcher/README.md "$DIST_DIR/"
        fi
        
        # Create build info
        {
          echo "ACPIPatcher Stuart Build Information"
          echo "==================================="
          echo "Build System: Stuart (edk2-pytool-extensions)"
          echo "Architecture: ${{ matrix.arch }}"
          echo "Build Type: ${{ matrix.build_type }}"
          echo "Toolchain: ${{ matrix.toolchain }}"
          echo "Platform: ${{ matrix.os }}"
          echo "Build Date: $(date -u)"
          echo "EDK2 Version: ${{ env.EDK2_VERSION }}"
        } > "$DIST_DIR/BUILD_INFO.txt"
        
        # Create archive
        if [ "${{ matrix.os }}" == "windows" ]; then
          # Try to create zip on Windows
          if command -v zip >/dev/null 2>&1; then
            zip -r "$DIST_DIR.zip" "$DIST_DIR"
          else
            tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
          fi
        else
          tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
        fi
        
        echo "✅ Created distribution package: $DIST_DIR"

    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ACPIPatcher-Stuart-${{ matrix.build_type }}-${{ matrix.arch }}-${{ matrix.os }}
        path: |
          edk2/ACPIPatcher-Stuart-*.tar.gz
          edk2/ACPIPatcher-Stuart-*.zip
        retention-days: 30
        if-no-files-found: warn

  # Summary job
  stuart-build-summary:
    name: Stuart Build Summary
    runs-on: ubuntu-latest
    needs: [stuart-build]
    if: always()
    
    steps:
    - name: Generate Build Summary
      run: |
        echo "## ACPIPatcher Stuart Build Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Build Matrix Results" >> $GITHUB_STEP_SUMMARY
        echo "| Platform | Architecture | Build Type | Toolchain | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|--------------|------------|-----------|--------|" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.stuart-build.result }}" = "success" ]; then
          echo "| Windows | X64/IA32 | RELEASE/DEBUG | GCC5 | ✅ Success |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| Windows | X64/IA32 | RELEASE/DEBUG | GCC5 | ❌ Failed |" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Stuart Build System" >> $GITHUB_STEP_SUMMARY
        echo "This workflow uses the official TianoCore Stuart build system:" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ System Python integration (avoiding virtual environment isolation issues)" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ Automated dependency management" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ Binary download and caching" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ Comprehensive CI integration" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ Cross-platform support" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Artifacts" >> $GITHUB_STEP_SUMMARY
        echo "Built EFI binaries are available in the Actions artifacts section." >> $GITHUB_STEP_SUMMARY
