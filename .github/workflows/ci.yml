name: Build ACPIPatcher

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  EDK2_VERSION: edk2-stable202405

jobs:
  build:
    name: Build ${{ matrix.os }} (${{ matrix.arch }}, ${{ matrix.build_type }})
    runs-on: ${{ matrix.runner }}
    
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux builds
          - os: linux
            runner: ubuntu-latest
            arch: X64
            build_type: RELEASE
            toolchain: GCC5
          - os: linux
            runner: ubuntu-latest
            arch: X64
            build_type: DEBUG
            toolchain: GCC5
          - os: linux
            runner: ubuntu-latest
            arch: IA32
            build_type: RELEASE
            toolchain: GCC5
          
          # macOS builds
          - os: macos
            runner: macos-13
            arch: X64
            build_type: RELEASE
            toolchain: XCODE5
          - os: macos
            runner: macos-13
            arch: X64
            build_type: DEBUG
            toolchain: XCODE5
          
          # Windows builds
          - os: windows
            runner: windows-latest
            arch: X64
            build_type: RELEASE
            toolchain: VS2022
          - os: windows
            runner: windows-latest
            arch: X64
            build_type: DEBUG
            toolchain: VS2022
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    # Platform-specific dependency installation
    - name: Install Linux Dependencies
      if: matrix.os == 'linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential nasm uuid-dev gcc-multilib
    
    - name: Install macOS Dependencies
      if: matrix.os == 'macos'
      run: |
        brew install nasm mtoc
    
    - name: Install Windows Dependencies
      if: matrix.os == 'windows'
      run: |
        choco install nasm
    
    # EDK2 setup with caching
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v3
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-${{ matrix.os }}-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      shell: bash
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        
        # Configure git for authentication issues
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          # Patch .gitmodules to disable problematic submodules (cross-platform)
          if [ -f "../acpipatcher/.github/scripts/patch-edk2-gitmodules.sh" ]; then
            echo "Patching .gitmodules to disable problematic submodules..."
            bash ../acpipatcher/.github/scripts/patch-edk2-gitmodules.sh
          fi
          
          # Now initialize submodules (problematic ones should be disabled)
          echo "Initializing EDK2 submodules..."
          if git submodule update --init --recommend-shallow; then
            echo "✅ Submodule initialization successful"
          else
            echo "⚠️ Some submodules failed to initialize, but continuing..."
          fi
          
          git submodule status | head -10 || echo "Submodule status check completed"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      shell: bash
      run: |
        cp -r acpipatcher/ACPIPatcherPkg edk2/
    
    # Build steps - Linux/macOS
    - name: Build on Unix (Linux/macOS)
      if: matrix.os != 'windows'
      run: |
        cd edk2
        . edksetup.sh
        
        # Build BaseTools with comprehensive error workarounds
        echo "Building EDK2 BaseTools..."
        export BUILD_SUCCESS=false
        
        # Try multiple approaches for BaseTools compilation
        echo "Attempt 1: Standard build with warning suppressions..."
        if make -C BaseTools CFLAGS="-w -Wno-error" 2>/dev/null; then
          echo "✅ BaseTools built successfully with warning suppressions"
          export BUILD_SUCCESS=true
        else
          echo "Attempt 2: Build with GCC version-specific flags..."
          if make -C BaseTools CFLAGS="-Wno-error=use-after-free -Wno-error=stringop-truncation -Wno-error=array-bounds -w" 2>/dev/null; then
            echo "✅ BaseTools built successfully with specific warning suppressions"
            export BUILD_SUCCESS=true
          else
            echo "Attempt 3: Force build with all warnings disabled..."
            if CC="gcc -w" make -C BaseTools 2>/dev/null; then
              echo "✅ BaseTools built successfully with all warnings disabled"
              export BUILD_SUCCESS=true
            else
              echo "Attempt 4: Last resort - clean and rebuild..."
              make -C BaseTools clean || true
              if make -C BaseTools CFLAGS="-O0 -w" || make -C BaseTools CFLAGS="-w" || make -C BaseTools; then
                echo "✅ BaseTools built successfully after clean"
                export BUILD_SUCCESS=true
              fi
            fi
          fi
        fi
        
        if [ "$BUILD_SUCCESS" != "true" ]; then
          echo "❌ All BaseTools build attempts failed"
          echo "Compiler information:"
          gcc --version || true
          make --version || true
          exit 1
        fi
        
        echo "Building ACPIPatcher..."
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t ${{ matrix.toolchain }} -p ACPIPatcherPkg/ACPIPatcherPkg.dsc
    
    # Build steps - Windows
    - name: Setup Visual Studio Environment
      if: matrix.os == 'windows'
      uses: microsoft/setup-msbuild@v1.3
    
    - name: Build on Windows
      if: matrix.os == 'windows'
      shell: cmd
      run: |
        cd edk2
        
        REM Setup Visual Studio environment with multiple fallbacks
        echo Setting up Visual Studio environment...
        call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvars64.bat" 2>nul && (
          echo ✅ VS2022 Enterprise environment loaded
          goto :build_setup
        )
        call "C:\Program Files\Microsoft Visual Studio\2022\Professional\VC\Auxiliary\Build\vcvars64.bat" 2>nul && (
          echo ✅ VS2022 Professional environment loaded
          goto :build_setup
        )
        call "C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat" 2>nul && (
          echo ✅ VS2022 Community environment loaded
          goto :build_setup
        )
        echo ⚠️ Warning: Could not find VS2022 environment, attempting to continue...
        
        :build_setup
        REM Initialize EDK2 environment
        call edksetup.bat
        if errorlevel 1 (
          echo ❌ EDK2 setup failed
          exit /b 1
        )
        
        REM Build BaseTools with multiple strategies
        echo Building BaseTools for Windows...
        cd BaseTools
        python -m pip install --upgrade pip >nul 2>&1
        
        REM Strategy 1: Try nmake with warning suppression
        echo Attempting BaseTools build with nmake...
        set CL=/W0
        set LINK=/IGNORE:4099
        nmake >nul 2>&1
        if not errorlevel 1 (
          echo ✅ BaseTools built successfully with nmake
          goto :verify_tools
        )
        
        REM Strategy 2: Try nmake with enhanced warning suppression
        echo nmake failed, trying with enhanced warning suppression...
        nmake clean >nul 2>&1
        set CFLAGS=/nologo /Z7 /c /O2 /MT /W0 /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE
        nmake CFLAGS="%CFLAGS%" >nul 2>&1
        if not errorlevel 1 (
          echo ✅ BaseTools built successfully with enhanced suppression
          goto :verify_tools
        )
        
        REM Strategy 3: Try python build
        echo Enhanced nmake failed, trying python build...
        python build.py >nul 2>&1
        if not errorlevel 1 (
          echo ✅ BaseTools built successfully with python
          goto :verify_tools
        )
        
        REM Strategy 4: Force nmake without error suppression
        echo Python build failed, trying forced nmake...
        if exist "Makefiles\ms.common" (
          echo Patching ms.common to remove /WX...
          powershell -Command "(Get-Content 'Makefiles\ms.common') -replace '/W4 /WX', '/W0' | Set-Content 'Makefiles\ms.common'"
        )
        nmake
        if not errorlevel 1 (
          echo ✅ BaseTools built successfully with forced nmake
          goto :verify_tools
        )
        
        echo ❌ All BaseTools build strategies failed
        exit /b 1
        
        :verify_tools
        REM Enhanced post-build verification and tool location
        echo Performing enhanced BaseTools verification...
        if not exist "Bin\Win32" (
          echo Creating missing Bin\Win32 directory...
          mkdir "Bin\Win32" 2>nul
          
          REM Check if tools were built in alternative locations and copy them
          echo Searching for built tools in alternative locations...
          if exist "Bin\*.exe" copy "Bin\*.exe" "Bin\Win32\" >nul 2>&1
          if exist "*.exe" copy "*.exe" "Bin\Win32\" >nul 2>&1
          
          REM Check Source\C subdirectories for built tools
          for /d %%D in (Source\C\*) do (
            if exist "%%D\*.exe" copy "%%D\*.exe" "Bin\Win32\" >nul 2>&1
          )
        )
        
        echo Listing contents of Bin\Win32:
        dir "Bin\Win32" 2>nul || echo No files in Bin\Win32 directory
        
        cd ..
        
        REM Ensure EDK_TOOLS_BIN is set correctly
        if "%EDK_TOOLS_BIN%"=="" (
          set "EDK_TOOLS_BIN=%WORKSPACE%\BaseTools\Bin\Win32"
          echo Set EDK_TOOLS_BIN to: %EDK_TOOLS_BIN%
        )
        
        REM Reset CL for application build
        set CL=
        
        REM Build ACPIPatcher
        echo Building ACPIPatcher...
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t ${{ matrix.toolchain }} -p ACPIPatcherPkg\ACPIPatcherPkg.dsc
        if errorlevel 1 (
          echo ❌ ACPIPatcher build failed
          exit /b 1
        )
        echo ✅ ACPIPatcher build completed successfully
    
    # Verification and packaging
    - name: Verify Build Output
      shell: bash
      run: |
        cd edk2
        BUILD_DIR="Build/ACPIPatcherPkg/${{ matrix.build_type }}_${{ matrix.toolchain }}/${{ matrix.arch }}"
        
        echo "Searching for build outputs..."
        echo "Expected build directory: $BUILD_DIR"
        
        # List all build directories to debug
        echo "All build directories:"
        find Build -type d -name "*ACPIPatcher*" 2>/dev/null || true
        find Build -name "*.efi" 2>/dev/null || true
        
        # Try multiple possible paths
        POSSIBLE_PATHS=(
          "$BUILD_DIR"
          "Build/ACPIPatcherPkg/${{ matrix.build_type }}_${{ matrix.toolchain }}/${{ matrix.arch }}"
          "Build/${{ matrix.build_type }}_${{ matrix.toolchain }}/${{ matrix.arch }}"
          "Build/ACPIPatcher/${{ matrix.build_type }}_${{ matrix.toolchain }}/${{ matrix.arch }}"
        )
        
        FOUND_DIR=""
        for path in "${POSSIBLE_PATHS[@]}"; do
          if [ -d "$path" ]; then
            echo "Found build directory: $path"
            ls -la "$path/" || true
            if [ -f "$path/ACPIPatcher.efi" ] || [ -f "$path/ACPIPatcherDxe.efi" ]; then
              FOUND_DIR="$path"
              break
            fi
          fi
        done
        
        if [ -z "$FOUND_DIR" ]; then
          echo "❌ No build directory with EFI files found"
          echo "Complete build tree:"
          ls -la Build/ || true
          find Build -name "*.efi" -o -name "*.dll" -o -name "*.exe" 2>/dev/null || true
          exit 1
        fi
        
        echo "Using build directory: $FOUND_DIR"
        
        # Check if binaries exist
        if [ -f "$FOUND_DIR/ACPIPatcher.efi" ]; then
          echo "✅ ACPIPatcher.efi built successfully"
          ls -la "$FOUND_DIR/ACPIPatcher.efi"
        else
          echo "❌ ACPIPatcher.efi not found in $FOUND_DIR"
          ls -la "$FOUND_DIR/" || true
          exit 1
        fi
        
        if [ -f "$FOUND_DIR/ACPIPatcherDxe.efi" ]; then
          echo "✅ ACPIPatcherDxe.efi built successfully"
          ls -la "$FOUND_DIR/ACPIPatcherDxe.efi"
        else
          echo "❌ ACPIPatcherDxe.efi not found in $FOUND_DIR"
          ls -la "$FOUND_DIR/" || true
          exit 1
        fi
        
        # Export the found directory for the next step
        echo "ACTUAL_BUILD_DIR=$FOUND_DIR" >> $GITHUB_ENV
    
    - name: Create Distribution Package
      shell: bash
      run: |
        cd edk2
        
        # Use the directory found in the previous step
        if [ -n "$ACTUAL_BUILD_DIR" ]; then
          BUILD_DIR="$ACTUAL_BUILD_DIR"
        else
          BUILD_DIR="Build/ACPIPatcherPkg/${{ matrix.build_type }}_${{ matrix.toolchain }}/${{ matrix.arch }}"
        fi
        
        DIST_DIR="ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-${{ matrix.os }}"
        
        echo "Creating distribution package from: $BUILD_DIR"
        mkdir -p "$DIST_DIR"
        
        # Copy binaries
        if [ -f "$BUILD_DIR/ACPIPatcher.efi" ]; then
          cp "$BUILD_DIR/ACPIPatcher.efi" "$DIST_DIR/"
          echo "✅ Copied ACPIPatcher.efi"
        fi
        
        if [ -f "$BUILD_DIR/ACPIPatcherDxe.efi" ]; then
          cp "$BUILD_DIR/ACPIPatcherDxe.efi" "$DIST_DIR/"
          echo "✅ Copied ACPIPatcherDxe.efi"
        fi
        
        # Copy documentation if it exists
        [ -f "../acpipatcher/README.md" ] && cp "../acpipatcher/README.md" "$DIST_DIR/" && echo "✅ Copied README.md"
        [ -f "../acpipatcher/DEBUG_GUIDE.md" ] && cp "../acpipatcher/DEBUG_GUIDE.md" "$DIST_DIR/" && echo "✅ Copied DEBUG_GUIDE.md"
        [ -f "../acpipatcher/IMPROVEMENTS.md" ] && cp "../acpipatcher/IMPROVEMENTS.md" "$DIST_DIR/" && echo "✅ Copied IMPROVEMENTS.md"
        [ -d "../acpipatcher/Build/ACPI" ] && cp -r "../acpipatcher/Build/ACPI" "$DIST_DIR/" && echo "✅ Copied ACPI samples"
        
        # Create build info
        {
          echo "ACPIPatcher Build Information"
          echo "============================"
          echo "Version: $(git -C ../acpipatcher describe --tags --always 2>/dev/null || echo 'unknown')"
          echo "Commit: $(git -C ../acpipatcher rev-parse HEAD 2>/dev/null || echo 'unknown')"
          echo "Build Date: $(date -u)"
          echo "Architecture: ${{ matrix.arch }}"
          echo "Build Type: ${{ matrix.build_type }}"
          echo "Toolchain: ${{ matrix.toolchain }}"
          echo "Platform: ${{ matrix.os }}"
          echo "Runner: ${{ matrix.runner }}"
          echo "Build Directory: $BUILD_DIR"
        } > "$DIST_DIR/BUILD_INFO.txt"
        
        echo "✅ Created BUILD_INFO.txt"
        
        # Show package contents
        echo "Package contents:"
        ls -la "$DIST_DIR/"
        
        # Create archive
        if [ "${{ matrix.os }}" = "windows" ]; then
          if command -v zip >/dev/null 2>&1; then
            zip -r "$DIST_DIR.zip" "$DIST_DIR"
            echo "✅ Created $DIST_DIR.zip"
          else
            echo "Warning: zip not available, creating tar.gz instead"
            tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
          fi
        else
          tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
          echo "✅ Created $DIST_DIR.tar.gz"
        fi
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-${{ matrix.os }}
        path: |
          edk2/ACPIPatcher-*.tar.gz
          edk2/ACPIPatcher-*.zip
        retention-days: 30
        if-no-files-found: error

  # Static analysis job
  static-analysis:
    name: Static Analysis
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Install Analysis Tools
      run: |
        sudo apt-get update
        sudo apt-get install -y cppcheck
    
    - name: Run CPPCheck
      run: |
        echo "Running CPPCheck static analysis..."
        cppcheck --enable=all --inconclusive --xml --xml-version=2 \
                 --suppress=missingIncludeSystem \
                 --suppress=unusedFunction \
                 ACPIPatcherPkg/ACPIPatcher/ 2> cppcheck-results.xml || true
        
        if [ -s cppcheck-results.xml ]; then
          echo "CPPCheck found issues:"
          cat cppcheck-results.xml
        else
          echo "✅ CPPCheck analysis passed"
        fi
    
    - name: Upload Analysis Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: static-analysis-results
        path: cppcheck-results.xml
        retention-days: 7

  # Summary job
  build-summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [build, static-analysis]
    if: always()
    
    steps:
    - name: Generate Summary
      run: |
        echo "## ACPIPatcher Build Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Build Matrix Results" >> $GITHUB_STEP_SUMMARY
        echo "| Platform | Architecture | Build Type | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|--------------|------------|--------|" >> $GITHUB_STEP_SUMMARY
        
        # Note: In a real scenario, you'd parse the matrix results
        # For now, we'll show the overall status
        if [ "${{ needs.build.result }}" = "success" ]; then
          echo "| All Platforms | All Architectures | All Types | ✅ Success |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| All Platforms | All Architectures | All Types | ❌ Failed |" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Static Analysis" >> $GITHUB_STEP_SUMMARY
        if [ "${{ needs.static-analysis.result }}" = "success" ]; then
          echo "✅ Static analysis completed successfully" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Static analysis failed or found issues" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Artifacts" >> $GITHUB_STEP_SUMMARY
        echo "Built binaries are available in the Actions artifacts section." >> $GITHUB_STEP_SUMMARY
