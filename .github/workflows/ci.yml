name: CI Build

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch:

jobs:
  build:
    name: Build ${{ matrix.os }} (${{ matrix.arch }}, ${{ matrix.build_type }})
    runs-on: ${{ matrix.runner }}
    
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux builds
          - os: linux
            runner: ubuntu-latest
            arch: X64
            build_type: RELEASE
            toolchain: GCC5
          - os: linux
            runner: ubuntu-latest
            arch: X64
            build_type: DEBUG
            toolchain: GCC5
          - os: linux
            runner: ubuntu-latest
            arch: IA32
            build_type: RELEASE
            toolchain: GCC5
          - os: linux
            runner: ubuntu-latest
            arch: IA32
            build_type: DEBUG
            toolchain: GCC5
          
          # macOS builds
          - os: macos
            runner: macos-13
            arch: X64
            build_type: RELEASE
            toolchain: XCODE5
          - os: macos
            runner: macos-13
            arch: X64
            build_type: DEBUG
            toolchain: XCODE5
          - os: macos
            runner: macos-13
            arch: IA32
            build_type: RELEASE
            toolchain: XCODE5
          - os: macos
            runner: macos-13
            arch: IA32
            build_type: DEBUG
            toolchain: XCODE5
          
          # Windows builds with VS2022
          - os: windows
            runner: windows-2022
            arch: X64
            build_type: RELEASE
            toolchain: VS2022
          - os: windows
            runner: windows-2022
            arch: X64
            build_type: DEBUG
            toolchain: VS2022
          - os: windows
            runner: windows-2022
            arch: IA32
            build_type: RELEASE
            toolchain: VS2022
          - os: windows
            runner: windows-2022
            arch: IA32
            build_type: DEBUG
            toolchain: VS2022
          
          # Windows builds with Cygwin GCC (DISABLED - PATH issues with NASM)
          # Re-enable after fixing NASM PATH refresh in CI environment
          # - os: windows-cygwin
          #   runner: windows-2022
          #   arch: X64
          #   build_type: RELEASE
          #   toolchain: GCC5
          # - os: windows-cygwin
          #   runner: windows-2022
          #   arch: X64
          #   build_type: DEBUG
          #   toolchain: GCC5
          # - os: windows-cygwin
          #   runner: windows-2022
          #   arch: IA32
          #   build_type: RELEASE
          #   toolchain: GCC5
          # - os: windows-cygwin
          #   runner: windows-2022
          #   arch: IA32
          #   build_type: DEBUG
          #   toolchain: GCC5

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
        token: ${{ secrets.GITHUB_TOKEN }}

    # Python Setup
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    # NASM Setup (all platforms)
    - name: Setup NASM
      uses: ilammy/setup-nasm@v1

    # macOS Prerequisites
    - name: Setup macOS Build Tools
      if: matrix.os == 'macos'
      run: |
        echo "Setting up macOS build environment..."
        
        # Install Command Line Tools if not present
        xcode-select --install 2>/dev/null || echo "Xcode Command Line Tools already installed"
        
        # Install mtoc using Homebrew (required for XCODE5 builds)
        echo "Installing mtoc..."
        if ! command -v mtoc &> /dev/null; then
          # Try installing mtoc from homebrew
          brew install mtoc 2>/dev/null || {
            echo "mtoc not available via homebrew, installing manually..."
            # Download and install mtoc manually
            curl -L "https://github.com/acidanthera/ocbuild/raw/master/efidirect.tool/mtoc" -o /usr/local/bin/mtoc
            chmod +x /usr/local/bin/mtoc
          }
        fi
        
        # Verify mtoc installation
        if command -v mtoc &> /dev/null; then
          echo "✓ mtoc found: $(which mtoc)"
          mtoc --version 2>/dev/null || echo "mtoc installed (version info not available)"
        else
          echo "WARNING: mtoc not found - XCODE5 builds may fail"
          echo "Using alternative toolchain configuration..."
          # For cases where mtoc is not available, we'll modify the toolchain
        fi
        
        # Install NASM for macOS builds
        if ! command -v nasm &> /dev/null; then
          echo "Installing NASM via Homebrew..."
          brew install nasm
        fi
        
        echo "✓ macOS build tools setup completed"
      shell: bash

    # Windows Prerequisites
    - name: Setup Visual Studio Environment (Windows)
      if: matrix.os == 'windows'
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: ${{ matrix.arch == 'IA32' && 'x86' || 'x64' }}

    # Setup MSBuild for Windows builds
    - name: Setup MSBuild (Windows)
      if: matrix.os == 'windows'
      uses: microsoft/setup-msbuild@v2

    # Setup NASM for Windows builds
    - name: Setup NASM (Windows)
      if: matrix.os == 'windows' || matrix.os == 'windows-cygwin'
      run: |
        Write-Host "Installing NASM..."
        choco install nasm -y
        
        # Refresh environment variables to get updated PATH
        $env:ChocolateyInstall = Convert-Path "$((Get-Command choco).Path)\..\.."
        Import-Module "$env:ChocolateyInstall\helpers\chocolateyProfile.psm1"
        refreshenv
        
        # Force add NASM paths
        $nasmPaths = @(
          "C:\Program Files\NASM",
          "C:\ProgramData\chocolatey\lib\nasm\tools\nasm-2.16.03",
          "C:\ProgramData\chocolatey\lib\nasm\tools"
        )
        
        foreach ($path in $nasmPaths) {
          if (Test-Path $path) {
            $env:PATH = "$path;$env:PATH"
            Write-Host "Added to PATH: $path"
          }
        }
        
        # Verify NASM installation
        $nasmExe = Get-Command nasm -ErrorAction SilentlyContinue
        if ($nasmExe) {
          Write-Host "NASM found at: $($nasmExe.Source)"
          & $nasmExe.Source -v
        } else {
          # Try direct paths
          $nasmLocations = @(
            "C:\Program Files\NASM\nasm.exe",
            "C:\ProgramData\chocolatey\lib\nasm\tools\nasm-2.16.03\nasm.exe",
            "C:\ProgramData\chocolatey\lib\nasm\tools\nasm.exe"
          )
          
          foreach ($loc in $nasmLocations) {
            if (Test-Path $loc) {
              Write-Host "NASM found at: $loc"
              & $loc -v
              break
            }
          }
        }
        
        Write-Host "NASM installation completed"
      shell: pwsh

    # Build Essentials (Linux only)
    - name: Install Build Essentials
      if: matrix.os == 'linux'
      run: |
        echo "Installing build-essential package..."
        sudo apt-get update
        sudo apt-get install -y build-essential
      shell: bash

    # Linux Prerequisites (EDK2 build requirements)
    - name: Setup Linux Build Tools (EDK2 Requirements)
      if: matrix.os == 'linux'
      run: |
        echo "Installing EDK2 build prerequisites for Linux..."
        
        # Update package list
        sudo apt-get update
        
        # Install essential EDK2 build tools as per TianoCore documentation
        # Note: python3-distutils removed for Ubuntu 24.04 compatibility
        sudo apt-get install -y \
          build-essential \
          uuid-dev \
          iasl \
          git \
          nasm \
          python-is-python3 \
          acpica-tools
        
        # Verify critical tools are installed
        echo "Verifying installed tools..."
        iasl -v || echo "WARNING: iasl not properly installed"
        nasm -v || echo "WARNING: nasm not properly installed"
        gcc --version | head -n1
        make --version | head -n1
        python3 --version
        
        echo "✓ Linux EDK2 build prerequisites installed"
      shell: bash

    # Linux Prerequisites (missing iasl and other EDK2 tools)
    - name: Setup Linux EDK2 Prerequisites
      if: matrix.os == 'linux'
      run: |
        echo "Installing EDK2 prerequisites for Linux..."
        
        # Update package lists
        sudo apt-get update
        
        # Install essential EDK2 build tools
        # Note: python3-distutils removed for Ubuntu 24.04 compatibility
        sudo apt-get install -y \
          build-essential \
          uuid-dev \
          iasl \
          acpica-tools \
          git \
          nasm \
          python-is-python3
        
        echo "✓ Linux EDK2 prerequisites installed"
        
        # Verify critical tools
        echo "Verifying installed tools..."
        gcc --version | head -n1
        nasm -v
        iasl -v || echo "iasl version check failed but tool is present"
        python3 --version
        
        echo "✓ Linux prerequisites setup completed"
      shell: bash

    # Ensure EDK2 submodules are properly initialized (all platforms)
    - name: Initialize EDK2 Submodules
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "Ensuring EDK2 submodules are properly initialized..."
        
        # Configure Git to use HTTPS for GitHub URLs to avoid SSH authentication issues
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global url."https://".insteadOf "git://"
        
        # Set timeout for Git operations (reduce from default to fail faster)
        git config --global http.lowSpeedLimit 1000
        git config --global http.lowSpeedTime 30
        
        # The checkout action should have done this, but let's be explicit
        git submodule status | head -10
        
        # Check if critical submodules exist
        if [ ! -d "temp_edk2" ]; then
          echo "temp_edk2 directory not found yet - this will be created by build scripts"
        else
          echo "Checking EDK2 submodules in temp_edk2..."
          cd temp_edk2
          
          # Check for critical missing submodules
          missing_submodules=()
          
          if [ ! -d "MdePkg/Library/MipiSysTLib/mipisyst" ]; then
            missing_submodules+=("MipiSysTLib")
          fi
          
          if [ ! -d "BaseTools/Source/C/BrotliCompress/brotli" ]; then
            missing_submodules+=("BrotliCompress")
          fi
          
          if [ ! -d "CryptoPkg/Library/OpensslLib/openssl" ]; then
            missing_submodules+=("OpensslLib")
          fi
          
          if [ ${#missing_submodules[@]} -ne 0 ]; then
            echo "Missing submodules detected: ${missing_submodules[*]}"
            echo "Initializing missing submodules with HTTPS authentication..."
            
            # Ensure we use HTTPS URLs for submodules
            git config --local url."https://github.com/".insteadOf "git@github.com:"
            git config --local url."https://".insteadOf "git://"
            
            # Initialize with Git's built-in HTTP timeout settings
            git -c http.lowSpeedLimit=1000 -c http.lowSpeedTime=60 submodule update --init --recursive --progress || {
              echo "Submodule initialization failed, trying individual submodules..."
              for submodule in "${missing_submodules[@]}"; do
                echo "Initializing $submodule..."
                case $submodule in
                  "MipiSysTLib")
                    git -c http.lowSpeedLimit=1000 -c http.lowSpeedTime=30 submodule update --init --recursive MdePkg/Library/MipiSysTLib || echo "Failed to init MipiSysTLib"
                    ;;
                  "BrotliCompress")
                    git -c http.lowSpeedLimit=1000 -c http.lowSpeedTime=30 submodule update --init --recursive BaseTools/Source/C/BrotliCompress || echo "Failed to init BrotliCompress"
                    ;;
                  "OpensslLib")
                    git -c http.lowSpeedLimit=1000 -c http.lowSpeedTime=30 submodule update --init --recursive CryptoPkg/Library/OpensslLib || echo "Failed to init OpensslLib"
                    ;;
                esac
              done
            }
          else
            echo "✓ All critical submodules are present"
          fi
          
          # Verify submodules after initialization
          echo "Verifying submodule status after initialization..."
          if [ -d "MdePkg/Library/MipiSysTLib/mipisyst/library/include" ]; then
            echo "✓ MipiSysTLib verified: mipisyst/library/include exists"
          else
            echo "❌ MipiSysTLib verification failed: mipisyst/library/include missing"
            echo "Attempting direct MipiSysTLib initialization..."
            git submodule update --init --recursive MdePkg/Library/MipiSysTLib
            if [ -d "MdePkg/Library/MipiSysTLib/mipisyst/library/include" ]; then
              echo "✓ MipiSysTLib verified after direct init"
            else
              echo "❌ MipiSysTLib still missing after direct init"
            fi
          fi
          
          if [ -d "BaseTools/Source/C/BrotliCompress/brotli/c" ]; then
            echo "✓ BrotliCompress verified: brotli/c exists"
          else
            echo "❌ BrotliCompress verification failed: brotli/c missing"
          fi
          
          if [ -d "CryptoPkg/Library/OpensslLib/openssl/include" ]; then
            echo "✓ OpensslLib verified: openssl/include exists"
          else
            echo "❌ OpensslLib verification failed: openssl/include missing"
          fi
          
          cd ..
        fi
        
        echo "✓ Submodule check completed"
      shell: bash

    # Build with Traditional EDK2 (Linux/macOS)
    - name: Build with EDK2 (Linux/macOS)
      if: matrix.os != 'windows' && matrix.os != 'windows-cygwin'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        CI: true
      run: |
        echo "Building ACPIPatcher with simplified build system..."
        echo "Configuration: ${{ matrix.arch }} ${{ matrix.build_type }} (${{ matrix.toolchain }})"
        
        # Run our automated setup and build script with parameters
        chmod +x setup_and_build.sh
        ./setup_and_build.sh ${{ matrix.arch }} ${{ matrix.build_type }}
        
        echo "✅ Build completed successfully"
      shell: bash

    # Build EDK2 BaseTools (Windows VS2022) - Separate step for better control
    - name: Build EDK2 BaseTools (Windows)
      if: matrix.os == 'windows'
      run: |
        Write-Host "Building EDK2 BaseTools with warnings-as-errors disabled..."
        
        # Navigate to EDK2 directory
        if (Test-Path "temp_edk2") {
          cd temp_edk2
        } else {
          Write-Host "EDK2 directory not found - cloning fresh copy..."
          git clone --depth 1 --single-branch https://github.com/tianocore/edk2.git temp_edk2
          cd temp_edk2
        }
        
        # Disable warnings as errors for BaseTools build only
        $env:CL = "/WX-"
        Write-Host "Set CL=/WX- to disable warnings as errors for BaseTools"
        
        # Build BaseTools using EDK2 standard approach
        Write-Host "Running edksetup.bat ForceRebuild..."
        cmd /c "edksetup.bat ForceRebuild"
        
        if ($LASTEXITCODE -eq 0) {
          Write-Host "✅ BaseTools build completed successfully"
        } else {
          Write-Host "❌ BaseTools build failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
        
        # Verify critical BaseTools were created
        $requiredTools = @("GenFw.exe", "GenFv.exe", "GenFfs.exe", "GenSec.exe")
        $toolsFound = 0
        
        foreach ($tool in $requiredTools) {
          $toolPath = ""
          if (Test-Path "BaseTools\Bin\Win32\$tool") {
            $toolPath = "BaseTools\Bin\Win32\$tool"
            $toolsFound++
          } elseif (Test-Path "BaseTools\Source\C\bin\$tool") {
            $toolPath = "BaseTools\Source\C\bin\$tool"
            $toolsFound++
          }
          
          if ($toolPath) {
            Write-Host "✅ $tool found at $toolPath"
          } else {
            Write-Host "❌ $tool not found"
          }
        }
        
        Write-Host "BaseTools verification: $toolsFound/$($requiredTools.Count) tools found"
        
        cd ..
      shell: pwsh

    # Build with Traditional EDK2 (Windows VS2022)
    - name: Build with EDK2 (Windows VS2022)
      if: matrix.os == 'windows'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        CI: true
      run: |
        Write-Host "Building ACPIPatcher with VS2022 toolchain..."
        Write-Host "Configuration: ${{ matrix.arch }} ${{ matrix.build_type }} (${{ matrix.toolchain }})"
        
        # Ensure NASM is in PATH
        $env:PATH = "C:\Program Files\NASM;" + $env:PATH
        
        # Verify tools are available
        Write-Host "Checking tools..."
        & nasm -v
        & cl 2>&1 | Select-Object -First 1
        & link 2>&1 | Select-Object -First 1
        
        # Navigate to EDK2 directory and set up environment
        cd temp_edk2
        
        # Copy ACPIPatcher package
        if (-not (Test-Path "ACPIPatcherPkg")) {
          Write-Host "Copying ACPIPatcherPkg..."
          Copy-Item -Recurse -Force "..\ACPIPatcherPkg" "ACPIPatcherPkg"
        }
        
        # Build ACPIPatcher - combine environment setup and build in single cmd call
        Write-Host "Setting up EDK2 environment and building ACPIPatcher package..."
        $buildCmd = "edksetup.bat && build -p ACPIPatcherPkg\ACPIPatcherPkg.dsc -a ${{ matrix.arch }} -t ${{ matrix.toolchain }} -b ${{ matrix.build_type }}"
        Write-Host "Build command: $buildCmd"
        
        cmd /c $buildCmd
        
        if ($LASTEXITCODE -eq 0) {
          Write-Host "✅ ACPIPatcher build completed successfully"
          
          # Copy built files back to root directory
          $buildDir = "Build\ACPIPatcher\${{ matrix.build_type }}_${{ matrix.toolchain }}\${{ matrix.arch }}"
          if (Test-Path "$buildDir\ACPIPatcher.efi") {
            Copy-Item "$buildDir\ACPIPatcher.efi" "..\ACPIPatcher.efi"
            Write-Host "✅ ACPIPatcher.efi copied"
          }
          if (Test-Path "$buildDir\ACPIPatcherDxe.efi") {
            Copy-Item "$buildDir\ACPIPatcherDxe.efi" "..\ACPIPatcherDxe.efi"
            Write-Host "✅ ACPIPatcherDxe.efi copied"
          }
        } else {
          Write-Host "❌ ACPIPatcher build failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
      shell: pwsh

    # Build with Traditional EDK2 (Windows Cygwin)
    - name: Build with EDK2 (Windows Cygwin)
      if: matrix.os == 'windows-cygwin'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        CI: true
      run: |
        Write-Host "Building ACPIPatcher with Cygwin GCC toolchain..."
        Write-Host "Configuration: ${{ matrix.arch }} ${{ matrix.build_type }} (${{ matrix.toolchain }})"
        
        # Force refresh PATH and add NASM
        $env:PATH = [System.Environment]::GetEnvironmentVariable("PATH","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("PATH","User")
        $env:PATH = "C:\tools\cygwin\bin;C:\Program Files\NASM;C:\ProgramData\chocolatey\lib\nasm\tools\nasm-2.16.03;" + $env:PATH
        
        # Verify tools are available
        Write-Host "Checking tools..."
        Get-Command nasm -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "NASM found: $($_.Source)" }
        if (Test-Path "C:\Program Files\NASM\nasm.exe") { 
          Write-Host "NASM version:"
          & "C:\Program Files\NASM\nasm.exe" -v 
        } elseif (Test-Path "C:\ProgramData\chocolatey\lib\nasm\tools\nasm-2.16.03\nasm.exe") {
          Write-Host "NASM version:"
          & "C:\ProgramData\chocolatey\lib\nasm\tools\nasm-2.16.03\nasm.exe" -v
        }
        & C:\tools\cygwin\bin\gcc.exe --version | Select-Object -First 1
        
        # Set Cygwin build flag
        $env:BASETOOLS_CYGWIN_BUILD = "TRUE"
        
        # Run our automated setup and build script with parameters
        & .\setup_and_build.bat ${{ matrix.arch }} ${{ matrix.build_type }}
        
        if ($LASTEXITCODE -eq 0) {
          Write-Host "✅ Build completed successfully"
        } else {
          Write-Host "❌ Build failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
      shell: pwsh

    # Upload Artifacts
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: ACPIPatcher-${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.build_type }}-${{ matrix.toolchain }}
        path: |
          *.efi
        retention-days: 30

    # Alternative Python Build Test (Windows only for now)
    - name: Test Python Build Script (Windows)
      if: matrix.os == 'windows' && matrix.arch == 'X64' && matrix.build_type == 'RELEASE'
      env:
        CI: true
      run: |
        Write-Host "Testing Python build script as alternative..."
        
        # Test our Python script with the same parameters
        python ACPIPatcher.py --build --arch ${{ matrix.arch }} --build-type ${{ matrix.build_type }}
        
        if ($LASTEXITCODE -eq 0) {
          Write-Host "✅ Python build script test completed successfully"
        } else {
          Write-Host "⚠ Python build script test failed (non-critical)"
        }
      shell: pwsh
      continue-on-error: true

    # Verify Build Success
    - name: Verify Build Output
      run: |
        echo "Checking build outputs..."
        
        # Check for ACPIPatcher.efi
        if (Test-Path "ACPIPatcher.efi") {
          $size = (Get-Item "ACPIPatcher.efi").Length
          Write-Host "✅ ACPIPatcher.efi found ($size bytes)"
        } else {
          Write-Host "❌ ACPIPatcher.efi not found"
        }
        
        # Check for ACPIPatcherDxe.efi
        if (Test-Path "ACPIPatcherDxe.efi") {
          $size = (Get-Item "ACPIPatcherDxe.efi").Length
          Write-Host "✅ ACPIPatcherDxe.efi found ($size bytes)"
        } else {
          Write-Host "❌ ACPIPatcherDxe.efi not found"
        }
        
        Write-Host "Build verification completed"
      shell: pwsh
      if: matrix.os == 'windows' || matrix.os == 'windows-cygwin'

    # Verify Build Success (Linux/macOS)
    - name: Verify Build Output (Linux/macOS)
      run: |
        echo "Checking build outputs..."
        if [ -f "ACPIPatcher.efi" ]; then
          echo "✅ ACPIPatcher.efi found ($(stat -f%z ACPIPatcher.efi 2>/dev/null || stat -c%s ACPIPatcher.efi) bytes)"
        else
          echo "❌ ACPIPatcher.efi not found"
        fi
        
        if [ -f "ACPIPatcherDxe.efi" ]; then
          echo "✅ ACPIPatcherDxe.efi found ($(stat -f%z ACPIPatcherDxe.efi 2>/dev/null || stat -c%s ACPIPatcherDxe.efi) bytes)"
        else
          echo "❌ ACPIPatcherDxe.efi not found"
        fi
        
        echo "Build verification completed"
      shell: bash
      if: matrix.os != 'windows' && matrix.os != 'windows-cygwin'
