name: Quick CI

on:
  push:
    branches: [ master, develop ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

env:
  EDK2_VERSION: edk2-stable202405

jobs:
  build:
    name: Build ${{ matrix.os }} (${{ matrix.arch }}, ${{ matrix.build_type }})
    runs-on: ${{ matrix.runner }}
    
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux builds
          - os: linux
            runner: ubuntu-latest
            arch: X64
            build_type: RELEASE
            toolchain: GCC5
          - os: linux
            runner: ubuntu-latest
            arch: X64
            build_type: DEBUG
            toolchain: GCC5
          - os: linux
            runner: ubuntu-latest
            arch: IA32
            build_type: RELEASE
            toolchain: GCC5
          
          # macOS builds
          - os: macos
            runner: macos-13
            arch: X64
            build_type: RELEASE
            toolchain: XCODE5
          - os: macos
            runner: macos-13
            arch: X64
            build_type: DEBUG
            toolchain: XCODE5
          
          # Windows builds
          - os: windows
            runner: windows-latest
            arch: X64
            build_type: RELEASE
            toolchain: VS2022
          - os: windows
            runner: windows-latest
            arch: X64
            build_type: DEBUG
            toolchain: VS2022
    
    steps:
    - name: Checkout ACPIPatcher
      uses: actions/checkout@v4
      with:
        path: acpipatcher
    
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'
    
    # Stuart Build System Setup
    - name: Setup Stuart Python Environment
      run: |
        echo "Setting up Stuart Python environment..."
        python -m pip install --upgrade pip setuptools wheel
        
        # Install Stuart dependencies if pip-requirements.txt exists
        if [ -f "acpipatcher/pip-requirements.txt" ]; then
          echo "Installing Stuart dependencies from pip-requirements.txt..."
          python -m pip install -r acpipatcher/pip-requirements.txt
        else
          echo "Installing core Stuart dependencies..."
          python -m pip install edk2-pytool-library>=0.21.0 edk2-pytool-extensions>=0.25.0
        fi
        
        # Verify Stuart installation
        python -c "import edk2toolext; print('Stuart tools installed successfully')" || echo "Stuart installation verification failed"
      shell: bash
    
    # Platform-specific dependency installation
    - name: Install Linux Dependencies
      if: matrix.os == 'linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential nasm uuid-dev gcc-multilib
    
    - name: Install macOS Dependencies
      if: matrix.os == 'macos'
      run: |
        brew install nasm mtoc
    
    - name: Setup MSYS2 and Build Tools (Windows)
      if: matrix.os == 'windows'
      uses: msys2/setup-msys2@v2
      with:
        msystem: MINGW64
        update: true
        install: >-
          mingw-w64-x86_64-clang
          mingw-w64-x86_64-llvm
          nasm
          make
          mingw-w64-x86_64-diffutils
          mingw-w64-x86_64-gcc
          git

    - name: Setup Visual Studio Environment (Windows)
      if: matrix.os == 'windows'
      uses: microsoft/setup-msbuild@v1.3.3
      
    - name: Setup Windows Build Environment
      if: matrix.os == 'windows'
      uses: ilammy/msvc-dev-cmd@v1.13.0
      with:
        arch: x64

    - name: Add MSYS2 Tools to Windows PATH
      if: matrix.os == 'windows'
      shell: pwsh
      run: |
        # Add MSYS2 paths to Windows PATH for access from cmd/batch
        # Using exact pattern from successful implementation
        $msys2Paths = @(
          "D:\a\_temp\msys64\mingw64\bin",
          "D:\a\_temp\msys64\usr\bin"
        )
        
        foreach ($path in $msys2Paths) {
          if (Test-Path $path) {
            echo "Adding to PATH: $path"
            echo "$path" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          } else {
            echo "Path not found: $path"
          }
        }
        
        # Also try to find MSYS2 installation dynamically
        $possibleMsys2Roots = @(
          "D:\a\_temp\msys64",
          "C:\msys64",
          "D:\msys64"
        )
        
        foreach ($root in $possibleMsys2Roots) {
          if (Test-Path "$root\mingw64\bin") {
            echo "Found MSYS2 at: $root"
            echo "$root\mingw64\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
            echo "$root\usr\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
            break
          }
        }

    - name: Set EDK2 Environment Variables (Windows)
      if: matrix.os == 'windows'
      shell: pwsh
      run: |
        # Set EDK2 environment variables to suppress warnings
        $msys2Root = "D:\a\_temp\msys64"
        if (-not (Test-Path $msys2Root)) {
          $msys2Root = "C:\msys64"
        }
        
        echo "Setting EDK2 environment variables..."
        echo "NASM_PREFIX=$msys2Root\usr\bin\" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "CLANG_BIN=$msys2Root\mingw64\bin\" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "CYGWIN_HOME=$msys2Root" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        
        echo "Environment variables set:"
        echo "NASM_PREFIX=$msys2Root\usr\bin\"
        echo "CLANG_BIN=$msys2Root\mingw64\bin\"
        echo "CYGWIN_HOME=$msys2Root"
    
    # EDK2 setup with caching
    - name: Cache EDK2
      id: cache-edk2
      uses: actions/cache@v4
      with:
        path: edk2
        key: edk2-${{ env.EDK2_VERSION }}-${{ matrix.os }}-${{ matrix.arch }}
    
    - name: Checkout EDK2
      if: steps.cache-edk2.outputs.cache-hit != 'true'
      shell: bash
      run: |
        git clone --depth=1 -b ${{ env.EDK2_VERSION }} https://github.com/tianocore/edk2.git
        cd edk2
        
        # Configure git for authentication issues
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global advice.detachedHead false
        
        # Use enhanced submodule initialization script
        if [ -f "../acpipatcher/.github/scripts/enhanced-submodule-init.sh" ]; then
          echo "Using enhanced submodule initialization..."
          bash ../acpipatcher/.github/scripts/enhanced-submodule-init.sh
        else
          echo "Enhanced script not found, falling back to basic initialization..."
          # Patch .gitmodules to disable problematic submodules (cross-platform)
          if [ -f "../acpipatcher/.github/scripts/patch-edk2-gitmodules.sh" ]; then
            echo "Patching .gitmodules to disable problematic submodules..."
            bash ../acpipatcher/.github/scripts/patch-edk2-gitmodules.sh
          fi
          
          # Now initialize submodules (problematic ones should be disabled)
          echo "Initializing EDK2 submodules..."
          if git submodule update --init --recommend-shallow; then
            echo "✅ Submodule initialization successful"
          else
            echo "⚠️ Some submodules failed to initialize, but continuing..."
          fi
          
          git submodule status | head -10 || echo "Submodule status check completed"
        fi
    
    - name: Copy ACPIPatcher to EDK2
      shell: bash
      run: |
        cp -r acpipatcher/ACPIPatcherPkg edk2/

    - name: Setup Python Virtual Environment (Stuart) - Unix
      if: matrix.os != 'windows'
      shell: bash
      run: |
        cd edk2
        
        echo "=== Setting up Stuart-inspired build environment ==="
        
        # Copy pip requirements to EDK2 directory
        cp ../acpipatcher/pip-requirements.txt . 2>/dev/null || true
        
        echo "Creating Python virtual environment..."
        python3 -m venv .venv
        
        echo "Activating virtual environment..."
        source .venv/bin/activate
        
        echo "Installing EDK2 Python tools following Stuart documentation..."
        python -m pip install --upgrade pip
        
        if [ -f "pip-requirements.txt" ]; then
          pip install -r pip-requirements.txt --upgrade
        else
          pip install edk2-pytool-library edk2-pytool-extensions
        fi
        
        echo "✅ Python virtual environment setup complete"

    - name: Stuart Dependencies Update (Unix)
      if: matrix.os != 'windows'
      shell: bash
      run: |
        cd edk2
        
        echo "=== Stuart Setup: Updating Dependencies ==="
        source .venv/bin/activate
        
        # Git submodules update (Stuart documentation step)
        echo "Updating git submodules..."
        git submodule update --init --recursive
        
        # Copy Stuart configuration if available
        if [ -d "../acpipatcher/.pytool" ]; then
          cp -r ../acpipatcher/.pytool . 2>/dev/null || true
          echo "✅ Copied Stuart configuration files"
        fi
        
        echo "✅ Stuart dependencies update completed"
    
    # Build steps - Stuart approach for all platforms
    - name: Build with Stuart-Inspired Approach (Unix)
      if: matrix.os != 'windows'
      shell: bash
      continue-on-error: true
      run: |
        cd edk2
        
        echo "=== Building with Stuart-inspired approach ==="
        source .venv/bin/activate
        
        export WORKSPACE=$(pwd)
        export EDK_TOOLS_PATH="$WORKSPACE/BaseTools"
        export PYTHON_COMMAND="python"
        
        # Try Stuart-style build first
        echo "Building BaseTools with Python tools..."
        if python BaseTools/Edk2ToolsBuild.py -t ${{ matrix.toolchain }}; then
          echo "✅ BaseTools built with Python tools"
          
          echo "Building ACPIPatcher with Python tools..."
          if python BaseTools/BinWrappers/PosixLike/build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t ${{ matrix.toolchain }} -p ACPIPatcherPkg/ACPIPatcherPkg.dsc; then
            echo "✅ Stuart build completed successfully"
            echo "STUART_BUILD_SUCCESS=true" >> $GITHUB_ENV
            exit 0
          fi
        fi
        
        echo "❌ Stuart build failed, will use traditional build"
        echo "STUART_BUILD_SUCCESS=false" >> $GITHUB_ENV

    - name: Build on Unix (Traditional Fallback)
      if: matrix.os != 'windows' && env.STUART_BUILD_SUCCESS != 'true'
      shell: bash
      run: |
        cd edk2
        . edksetup.sh
        
        # Traditional BaseTools build with comprehensive error workarounds
        echo "Building EDK2 BaseTools..."
        export BUILD_SUCCESS=false
        
        # Try multiple approaches for BaseTools compilation
        echo "Attempt 1: Standard build with warning suppressions..."
        if make -C BaseTools CFLAGS="-w -Wno-error" 2>/dev/null; then
          echo "✅ BaseTools built successfully with warning suppressions"
          export BUILD_SUCCESS=true
        else
          echo "Attempt 2: Build with GCC version-specific flags..."
          if make -C BaseTools CFLAGS="-Wno-error=use-after-free -Wno-error=stringop-truncation -Wno-error=array-bounds -w" 2>/dev/null; then
            echo "✅ BaseTools built successfully with specific warning suppressions"
            export BUILD_SUCCESS=true
          else
            echo "Attempt 3: Force build with all warnings disabled..."
            if CC="gcc -w" make -C BaseTools 2>/dev/null; then
              echo "✅ BaseTools built successfully with all warnings disabled"
              export BUILD_SUCCESS=true
            else
              echo "Attempt 4: Last resort - clean and rebuild..."
              make -C BaseTools clean || true
              if make -C BaseTools CFLAGS="-O0 -w" || make -C BaseTools CFLAGS="-w" || make -C BaseTools; then
                echo "✅ BaseTools built successfully after clean"
                export BUILD_SUCCESS=true
              fi
            fi
          fi
        fi
        
        if [ "$BUILD_SUCCESS" != "true" ]; then
          echo "❌ All BaseTools build attempts failed"
          echo "Compiler information:"
          gcc --version || true
          make --version || true
          exit 1
        fi
        
        echo "Building ACPIPatcher..."
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t ${{ matrix.toolchain }} -p ACPIPatcherPkg/ACPIPatcherPkg.dsc
    
    - name: Verify EDK2 Environment Variables (Windows)
      if: matrix.os == 'windows'
      shell: cmd
      run: |
        echo === Verifying EDK2 Environment Variables ===
        echo NASM_PREFIX=%NASM_PREFIX%
        echo CLANG_BIN=%CLANG_BIN%
        echo CYGWIN_HOME=%CYGWIN_HOME%
        echo.
        
        REM Test if the paths actually exist and contain the expected tools
        if exist "%NASM_PREFIX%nasm.exe" (
          echo ✓ NASM found at: %NASM_PREFIX%nasm.exe
          "%NASM_PREFIX%nasm.exe" -version | findstr "version"
        ) else (
          echo ✗ NASM not found at: %NASM_PREFIX%nasm.exe
        )
        
        if exist "%CLANG_BIN%clang.exe" (
          echo ✓ Clang found at: %CLANG_BIN%clang.exe
          "%CLANG_BIN%clang.exe" --version | findstr "clang version"
        ) else (
          echo ✗ Clang not found at: %CLANG_BIN%clang.exe
        )
        
        REM Verify Visual Studio environment
        echo.
        echo === Verifying Visual Studio Environment ===
        where cl >nul 2>&1
        if %ERRORLEVEL%==0 (
          echo ✓ Visual Studio compiler accessible
          cl 2>&1 | findstr "Microsoft"
        ) else (
          echo ✗ Visual Studio compiler not accessible
        )

    - name: Build with Stuart-Inspired Approach (Windows)
      if: matrix.os == 'windows'
      shell: pwsh
      continue-on-error: true
      run: |
        cd edk2
        
        Write-Host "=== Building with Stuart-inspired approach ==="
        .\.venv\Scripts\Activate.ps1
        
        $env:WORKSPACE = $PWD.Path
        $env:EDK_TOOLS_PATH = "$PWD\BaseTools"
        $env:PYTHON_COMMAND = "python"
        
        try {
          Write-Host "Building BaseTools with Python tools..."
          python BaseTools/Edk2ToolsBuild.py -t VS2022
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "✅ BaseTools built with VS2022"
            
            Write-Host "Building ACPIPatcher with Python tools..."
            python BaseTools/BinWrappers/PosixLike/build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t VS2022 -p ACPIPatcherPkg\ACPIPatcherPkg.dsc
            
            if ($LASTEXITCODE -eq 0) {
              Write-Host "✅ Stuart build completed successfully"
              echo "STUART_BUILD_SUCCESS=true" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
              exit 0
            }
          }
          
          # Try with VS2019 if VS2022 fails
          Write-Host "Trying VS2019 toolchain..."
          python BaseTools/Edk2ToolsBuild.py -t VS2019
          if ($LASTEXITCODE -eq 0) {
            python BaseTools/BinWrappers/PosixLike/build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t VS2019 -p ACPIPatcherPkg\ACPIPatcherPkg.dsc
            if ($LASTEXITCODE -eq 0) {
              Write-Host "✅ Stuart build completed with VS2019"
              echo "STUART_BUILD_SUCCESS=true" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
              exit 0
            }
          }
        } catch {
          Write-Host "Stuart build encountered errors"
        }
        
        Write-Host "❌ Stuart build failed, will use traditional build"
        echo "STUART_BUILD_SUCCESS=false" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

    - name: Build on Windows (Traditional Fallback)
      if: matrix.os == 'windows' && env.STUART_BUILD_SUCCESS != 'true'
      shell: cmd
      run: |
        cd edk2
        
        REM ====================================================================
        REM Simplified setup using MSYS2 tools with pre-set environment variables
        REM ====================================================================
        echo Setting up EDK2 environment with MSYS2 tools...
        
        REM Test if clang is accessible from Windows cmd (should be via GITHUB_PATH)
        where clang >nul 2>&1
        if %ERRORLEVEL%==0 (
          echo ✓ Clang accessible from Windows batch
          clang --version | findstr "clang version"
        ) else (
          echo ✗ Clang not accessible from Windows batch
          exit /b 1
        )
        
        REM Test if nasm is accessible from Windows cmd  
        where nasm >nul 2>&1
        if %ERRORLEVEL%==0 (
          echo ✓ NASM accessible from Windows batch
          nasm -version | findstr "version"
        ) else (
          echo ✗ NASM not accessible from Windows batch
          exit /b 1
        )
        
        REM Set up workspace
        set "WORKSPACE=%GITHUB_WORKSPACE%\edk2"
        echo Set WORKSPACE to: %WORKSPACE%
        
        REM Environment variables already set in previous step via GITHUB_ENV
        echo Using pre-configured EDK2 environment variables:
        echo NASM_PREFIX=%NASM_PREFIX%
        echo CLANG_BIN=%CLANG_BIN%
        echo CYGWIN_HOME=%CYGWIN_HOME%
        
        REM Set BASE_TOOLS_PATH before building
        set "BASE_TOOLS_PATH=%WORKSPACE%\BaseTools"
        echo Set BASE_TOOLS_PATH to: %BASE_TOOLS_PATH%
        
        REM Build BaseTools FIRST, before calling edksetup.bat
        echo Building BaseTools with warning suppression...
        cd BaseTools
        
        REM Ensure Win32 directory exists
        if not exist "Bin\Win32" mkdir "Bin\Win32"
        
        REM Patch Makefiles to disable warnings-as-errors before building
        if exist "Makefiles\ms.common" (
          echo Patching ms.common to disable warnings-as-errors...
          REM More aggressive patching to override all warning flags
          powershell -Command "(Get-Content 'Makefiles\ms.common') -replace '/W[0-4]', '/W0' | Set-Content 'Makefiles\ms.common'"
          powershell -Command "(Get-Content 'Makefiles\ms.common') -replace '/WX', '/WX-' | Set-Content 'Makefiles\ms.common'"
          powershell -Command "(Get-Content 'Makefiles\ms.common') -replace '/wd[0-9]+', '' | Set-Content 'Makefiles\ms.common'"
          echo ✓ Patched ms.common to disable warnings-as-errors
        )
        
        REM Also patch makefile.common if it exists
        if exist "Makefiles\makefile.common" (
          echo Patching makefile.common to disable warnings-as-errors...
          powershell -Command "(Get-Content 'Makefiles\makefile.common') -replace '/W[0-4]', '/W0' | Set-Content 'Makefiles\makefile.common'"
          powershell -Command "(Get-Content 'Makefiles\makefile.common') -replace '/WX', '/WX-' | Set-Content 'Makefiles\makefile.common'"
          echo ✓ Patched makefile.common to disable warnings-as-errors
        )
        
        REM Build BaseTools with comprehensive warning suppression
        echo Attempting BaseTools build with comprehensive warning suppression...
        set "CFLAGS=/W0 /WX- /wd4267 /wd4244 /wd4311 /wd4312 /wd4996 /wd4101 /wd4100"
        set "MAKEFLAGS=CFLAGS=%CFLAGS%"
        nmake
        if %ERRORLEVEL%==0 (
          echo ✓ BaseTools built successfully
        ) else (
          echo ⚠ BaseTools build failed, attempting retry without makefile patches...
          nmake clean >nul 2>&1
          set "CFLAGS="
          set "MAKEFLAGS="
          nmake
          if %ERRORLEVEL%==0 (
            echo ✓ BaseTools built successfully on retry
          ) else (
            echo ✗ BaseTools build failed on retry, continuing anyway...
          )
        )
        
        REM Verify BaseTools were built
        echo Verifying BaseTools build results...
        if exist "Bin\Win32\GenFw.exe" (
          echo ✓ GenFw.exe found
        ) else (
          echo ✗ GenFw.exe not found - this may cause build failures
        )
        
        if exist "Bin\Win32\build.exe" (
          echo ✓ build.exe found
        ) else (
          echo ✗ build.exe not found - this may cause build failures
        )
        
        REM Add BaseTools to PATH
        set "PATH=%WORKSPACE%\BaseTools\Bin\Win32;%PATH%"
        echo Added BaseTools to PATH
        
        cd ..
        
        REM Call edksetup.bat
        echo Calling edksetup.bat...
        call edksetup.bat
        if %ERRORLEVEL%==0 (
          echo ✓ edksetup.bat completed successfully
        ) else (
          echo ⚠ edksetup.bat reported issues, but continuing...
        )
        
        REM Re-sourcing Visual Studio environment to ensure toolchain is available
        echo Re-sourcing Visual Studio environment...
        call "%VCToolsInstallDir%\..\..\Auxiliary\Build\vcvarsall.bat" x64
        
        REM Verify VS2022 toolchain availability
        echo Checking VS2022 toolchain availability...
        if exist "%WORKSPACE%\Conf\tools_def.txt" (
          findstr /C:"VS2022_BIN" "%WORKSPACE%\Conf\tools_def.txt" >nul
          if %ERRORLEVEL%==0 (
            echo ✓ VS2022 toolchain found in tools_def.txt
          ) else (
            echo ⚠ VS2022 toolchain not found, attempting to use VS2019 as fallback...
            findstr /C:"VS2019_BIN" "%WORKSPACE%\Conf\tools_def.txt" >nul
            if %ERRORLEVEL%==0 (
              echo ✓ Using VS2019 toolchain as fallback
            ) else (
              echo ✗ Neither VS2022 nor VS2019 toolchain found
            )
          )
        )
        
        REM Set up Python environment for BaseTools
        echo Setting up Python environment for BaseTools...
        
        REM Find and verify Python installation
        for %%p in (python python3 "py -3") do (
          %%p --version >nul 2>&1
          if not errorlevel 1 (
            echo ✓ Found working Python: %%p
            set "PYTHON_COMMAND=%%p"
            %%p --version
            goto :python_found
          )
        )
        
        REM Fallback: try common Python installation paths
        for %%d in ("C:\hostedtoolcache\windows\Python" "C:\Python*") do (
          if exist "%%d" (
            for /f "delims=" %%f in ('dir /b /s "%%d\python.exe" 2^>nul') do (
              "%%f" --version >nul 2>&1
              if not errorlevel 1 (
                echo ✓ Found Python at: %%f
                set "PYTHON_COMMAND=%%f"
                "%%f" --version
                goto :python_found
              )
            )
          )
        )
        
        echo ⚠ Could not find working Python, using default
        set "PYTHON_COMMAND=python"
        
        :python_found
        echo Using PYTHON_COMMAND=%PYTHON_COMMAND%
        
        REM Build ACPIPatcher
        echo Building ACPIPatcher...
        build -a ${{ matrix.arch }} -b ${{ matrix.build_type }} -t ${{ matrix.toolchain }} -p ACPIPatcherPkg\ACPIPatcherPkg.dsc
        if %ERRORLEVEL%==0 (
          echo ✓ ACPIPatcher built successfully
        ) else (
          echo ✗ ACPIPatcher build failed
          exit /b 1
        )
    
    # Verification and packaging
    - name: Verify Build Output
      shell: bash
      run: |
        cd edk2
        echo "=== Dynamic Build Artifact Discovery ==="
        echo "Searching for .efi files in Build directory..."
        find Build/ -name "*.efi" 2>/dev/null || echo "No .efi files found"
        
        echo "=== Artifact Validation ==="
        EFI_PATHS=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null || true)
        DXE_PATHS=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null || true)
        
        if [ -z "$EFI_PATHS" ] && [ -z "$DXE_PATHS" ]; then
          echo "❌ No EFI files found"
          echo "Complete build tree:"
          find Build/ -type f 2>/dev/null || true
          # Don't exit here to allow the workflow to continue
          echo "WARNING: No EFI files found, but continuing workflow"
        fi
        
        if [ -n "$EFI_PATHS" ]; then
          for path in $EFI_PATHS; do
            echo "✅ Found ACPIPatcher.efi: $path"
            ls -la "$path"
            file "$path" || true
          done
        fi
        
        if [ -n "$DXE_PATHS" ]; then
          for path in $DXE_PATHS; do
            echo "✅ Found ACPIPatcherDxe.efi: $path"
            ls -la "$path"
            file "$path" || true
          done
        fi
      continue-on-error: true
    
    - name: Create Distribution Package
      shell: bash
      run: |
        cd edk2
        
        echo "=== Dynamic Artifact Discovery for Distribution ==="
        EFI_PATH=$(find Build/ -name "ACPIPatcher.efi" 2>/dev/null | head -1)
        DXE_PATH=$(find Build/ -name "ACPIPatcherDxe.efi" 2>/dev/null | head -1)
        
        DIST_DIR="ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-${{ matrix.os }}"
        
        echo "Creating distribution package: $DIST_DIR"
        mkdir -p "$DIST_DIR"
        
        # Copy binaries using dynamic paths
        if [ -n "$EFI_PATH" ] && [ -f "$EFI_PATH" ]; then
          cp "$EFI_PATH" "$DIST_DIR/"
          echo "✅ Copied ACPIPatcher.efi from: $EFI_PATH"
        else
          echo "⚠️ ACPIPatcher.efi not found, creating placeholder file"
          echo "BUILD_FAILED: Could not find ACPIPatcher.efi" > "$DIST_DIR/ACPIPatcher.efi.missing"
        fi
        
        if [ -n "$DXE_PATH" ] && [ -f "$DXE_PATH" ]; then
          cp "$DXE_PATH" "$DIST_DIR/"
          echo "✅ Copied ACPIPatcherDxe.efi from: $DXE_PATH"
        else
          echo "⚠️ ACPIPatcherDxe.efi not found, creating placeholder file"
          echo "BUILD_FAILED: Could not find ACPIPatcherDxe.efi" > "$DIST_DIR/ACPIPatcherDxe.efi.missing"
        fi
        
        # Try alternative paths as fallback
        find Build/ -name "*.efi" -exec cp {} "$DIST_DIR/" \; 2>/dev/null || true
        
        # Copy documentation using correct paths
        echo "=== Copying Documentation and Samples ==="
        
        # Find and copy documentation files from parent acpipatcher directory
        echo "Checking for documentation files..."
        echo "Current directory: $(pwd)"
        echo "Parent directory contents:"
        ls -la ../ || echo "Cannot list parent directory"
        
        # Try multiple possible paths for the acpipatcher source
        SOURCE_PATHS=("../acpipatcher" "../ACPIPatcher" "../../acpipatcher" "../../ACPIPatcher")
        
        FOUND_SOURCE=""
        for path in "${SOURCE_PATHS[@]}"; do
          if [ -f "$path/README.md" ]; then
            FOUND_SOURCE="$path"
            echo "✅ Found source directory: $path"
            break
          fi
        done
        
        if [ -n "$FOUND_SOURCE" ]; then
          # Copy documentation files
          [ -f "$FOUND_SOURCE/README.md" ] && cp "$FOUND_SOURCE/README.md" "$DIST_DIR/" && echo "✅ Copied README.md"
          [ -f "$FOUND_SOURCE/DEBUG_GUIDE.md" ] && cp "$FOUND_SOURCE/DEBUG_GUIDE.md" "$DIST_DIR/" && echo "✅ Copied DEBUG_GUIDE.md"
          [ -f "$FOUND_SOURCE/IMPROVEMENTS.md" ] && cp "$FOUND_SOURCE/IMPROVEMENTS.md" "$DIST_DIR/" && echo "✅ Copied IMPROVEMENTS.md"
          [ -f "$FOUND_SOURCE/EFI_1X_COMPATIBILITY.md" ] && cp "$FOUND_SOURCE/EFI_1X_COMPATIBILITY.md" "$DIST_DIR/" && echo "✅ Copied EFI_1X_COMPATIBILITY.md"
          
          # Copy ACPI samples if they exist
          if [ -d "$FOUND_SOURCE/Build/ACPI" ]; then
            cp -r "$FOUND_SOURCE/Build/ACPI" "$DIST_DIR/" && echo "✅ Copied ACPI samples"
          else
            echo "⚠️ No ACPI samples found in $FOUND_SOURCE/Build/ACPI"
          fi
        else
          echo "⚠️ Could not find source directory with documentation"
          echo "Searched paths: ${SOURCE_PATHS[*]}"
        fi
          echo "Looking for ACPI directory..."
          find ../acpipatcher -name "ACPI" -type d 2>/dev/null || echo "No ACPI directory found"
        
        # Create build info
        {
          echo "ACPIPatcher Build Information"
          echo "============================"
          echo "Version: $(git -C ../acpipatcher describe --tags --always 2>/dev/null || echo 'unknown')"
          echo "Commit: $(git -C ../acpipatcher rev-parse HEAD 2>/dev/null || echo 'unknown')"
          echo "Build Date: $(date -u)"
          echo "Architecture: ${{ matrix.arch }}"
          echo "Build Type: ${{ matrix.build_type }}"
          echo "Toolchain: ${{ matrix.toolchain }}"
          echo "Platform: ${{ matrix.os }}"
          echo "Runner: ${{ matrix.runner }}"
          echo "Artifacts Used:"
          echo "  EFI: $EFI_PATH"
          echo "  DXE: $DXE_PATH"
        } > "$DIST_DIR/BUILD_INFO.txt"
        
        echo "✅ Created BUILD_INFO.txt"
        
        # Show package contents
        echo "Package contents:"
        ls -la "$DIST_DIR/"
        
        # Create archive
        if [ "${{ matrix.os }}" = "windows" ]; then
          if command -v zip >/dev/null 2>&1; then
            zip -r "$DIST_DIR.zip" "$DIST_DIR"
            echo "✅ Created $DIST_DIR.zip"
          else
            echo "Warning: zip not available, creating tar.gz instead"
            tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
          fi
        else
          tar -czf "$DIST_DIR.tar.gz" "$DIST_DIR"
          echo "✅ Created $DIST_DIR.tar.gz"
        fi
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ACPIPatcher-${{ matrix.build_type }}-${{ matrix.arch }}-${{ matrix.os }}
        path: |
          edk2/ACPIPatcher-*.tar.gz
          edk2/ACPIPatcher-*.zip
        retention-days: 30
        if-no-files-found: warn
      continue-on-error: true

  # Static analysis job
  static-analysis:
    name: Static Analysis
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Install Analysis Tools
      run: |
        sudo apt-get update
        sudo apt-get install -y cppcheck
    
    - name: Run CPPCheck
      run: |
        echo "Running CPPCheck static analysis..."
        cppcheck --enable=all --inconclusive --xml --xml-version=2 \
                 --suppress=missingIncludeSystem \
                 --suppress=unusedFunction \
                 ACPIPatcherPkg/ACPIPatcher/ 2> cppcheck-results.xml || true
        
        if [ -s cppcheck-results.xml ]; then
          echo "CPPCheck found issues:"
          cat cppcheck-results.xml
        else
          echo "✅ CPPCheck analysis passed"
        fi
    
    - name: Upload Analysis Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: static-analysis-results
        path: cppcheck-results.xml
        retention-days: 7

  # Summary job
  build-summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [build, static-analysis]
    if: always()
    
    steps:
    - name: Generate Summary
      run: |
        echo "## ACPIPatcher Build Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Build Matrix Results" >> $GITHUB_STEP_SUMMARY
        echo "| Platform | Architecture | Build Type | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|--------------|------------|--------|" >> $GITHUB_STEP_SUMMARY
        
        # Note: In a real scenario, you'd parse the matrix results
        # For now, we'll show the overall status
        if [ "${{ needs.build.result }}" = "success" ]; then
          echo "| All Platforms | All Architectures | All Types | ✅ Success |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| All Platforms | All Architectures | All Types | ❌ Failed |" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Static Analysis" >> $GITHUB_STEP_SUMMARY
        if [ "${{ needs.static-analysis.result }}" = "success" ]; then
          echo "✅ Static analysis completed successfully" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Static analysis failed or found issues" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Artifacts" >> $GITHUB_STEP_SUMMARY
        echo "Built binaries are available in the Actions artifacts section." >> $GITHUB_STEP_SUMMARY
