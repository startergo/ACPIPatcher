name: CI Build

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch:

jobs:
  build:
    name: Build ${{ matrix.os }} (${{ matrix.arch }}, ${{ matrix.build_type }})
    runs-on: ${{ matrix.runner }}
    
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux builds
          - os: linux
            runner: ubuntu-latest
            arch: X64
            build_type: RELEASE
            toolchain: GCC5
          - os: linux
            runner: ubuntu-latest
            arch: X64
            build_type: DEBUG
            toolchain: GCC5
          - os: linux
            runner: ubuntu-latest
            arch: IA32
            build_type: RELEASE
            toolchain: GCC5
          - os: linux
            runner: ubuntu-latest
            arch: IA32
            build_type: DEBUG
            toolchain: GCC5
          
          # macOS builds
          - os: macos
            runner: macos-13
            arch: X64
            build_type: RELEASE
            toolchain: XCODE5
          - os: macos
            runner: macos-13
            arch: X64
            build_type: DEBUG
            toolchain: XCODE5
          - os: macos
            runner: macos-13
            arch: IA32
            build_type: RELEASE
            toolchain: XCODE5
          - os: macos
            runner: macos-13
            arch: IA32
            build_type: DEBUG
            toolchain: XCODE5
          
          # Windows builds with VS2022
          - os: windows
            runner: windows-2022
            arch: X64
            build_type: RELEASE
            toolchain: VS2022
          - os: windows
            runner: windows-2022
            arch: X64
            build_type: DEBUG
            toolchain: VS2022
          - os: windows
            runner: windows-2022
            arch: IA32
            build_type: RELEASE
            toolchain: VS2022
          - os: windows
            runner: windows-2022
            arch: IA32
            build_type: DEBUG
            toolchain: VS2022
          
          # Windows builds with Cygwin GCC (DISABLED - PATH issues with NASM)
          # Re-enable after fixing NASM PATH refresh in CI environment
          # - os: windows-cygwin
          #   runner: windows-2022
          #   arch: X64
          #   build_type: RELEASE
          #   toolchain: GCC5
          # - os: windows-cygwin
          #   runner: windows-2022
          #   arch: X64
          #   build_type: DEBUG
          #   toolchain: GCC5
          # - os: windows-cygwin
          #   runner: windows-2022
          #   arch: IA32
          #   build_type: RELEASE
          #   toolchain: GCC5
          # - os: windows-cygwin
          #   runner: windows-2022
          #   arch: IA32
          #   build_type: DEBUG
          #   toolchain: GCC5

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
        token: ${{ secrets.GITHUB_TOKEN }}

    # Python Setup
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    # NASM Setup (all platforms)
    - name: Setup NASM
      uses: ilammy/setup-nasm@v1

    # macOS Prerequisites
    - name: Setup macOS Build Tools
      if: matrix.os == 'macos'
      run: |
        echo "Setting up macOS build environment..."
        
        # Install Command Line Tools if not present
        xcode-select --install 2>/dev/null || echo "Xcode Command Line Tools already installed"
        
        # Install mtoc using Homebrew (required for XCODE5 builds)
        echo "Installing mtoc..."
        if ! command -v mtoc &> /dev/null; then
          # Try installing mtoc from homebrew
          brew install mtoc 2>/dev/null || {
            echo "mtoc not available via homebrew, installing manually..."
            # Download and install mtoc manually
            curl -L "https://github.com/acidanthera/ocbuild/raw/master/efidirect.tool/mtoc" -o /usr/local/bin/mtoc
            chmod +x /usr/local/bin/mtoc
          }
        fi
        
        # Verify mtoc installation
        if command -v mtoc &> /dev/null; then
          echo "✓ mtoc found: $(which mtoc)"
          mtoc --version 2>/dev/null || echo "mtoc installed (version info not available)"
        else
          echo "WARNING: mtoc not found - XCODE5 builds may fail"
          echo "Using alternative toolchain configuration..."
          # For cases where mtoc is not available, we'll modify the toolchain
        fi
        
        # Install NASM for macOS builds
        if ! command -v nasm &> /dev/null; then
          echo "Installing NASM via Homebrew..."
          brew install nasm
        fi
        
        echo "✓ macOS build tools setup completed"
      shell: bash

    # Windows Prerequisites
    - name: Setup Visual Studio Environment (Windows)
      if: matrix.os == 'windows'
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: ${{ matrix.arch == 'IA32' && 'x86' || 'x64' }}

    # Setup MSBuild for Windows builds
    - name: Setup MSBuild (Windows)
      if: matrix.os == 'windows'
      uses: microsoft/setup-msbuild@v2

    # Note: NASM is already installed by ilammy/setup-nasm@v1 above
    # No additional Windows-specific NASM setup needed

    # Build Essentials (Linux only)
    - name: Install Build Essentials
      if: matrix.os == 'linux'
      run: |
        echo "Installing build-essential package..."
        sudo apt-get update
        sudo apt-get install -y build-essential
      shell: bash

    # Linux Prerequisites (EDK2 build requirements)
    - name: Setup Linux Build Tools (EDK2 Requirements)
      if: matrix.os == 'linux'
      run: |
        echo "Installing EDK2 build prerequisites for Linux..."
        
        # Update package list
        sudo apt-get update
        
        # Install essential EDK2 build tools as per TianoCore documentation
        # Note: python3-distutils removed for Ubuntu 24.04 compatibility
        sudo apt-get install -y \
          build-essential \
          uuid-dev \
          iasl \
          git \
          nasm \
          python-is-python3 \
          acpica-tools
        
        # Verify critical tools are installed
        echo "Verifying installed tools..."
        iasl -v || echo "WARNING: iasl not properly installed"
        nasm -v || echo "WARNING: nasm not properly installed"
        gcc --version | head -n1
        make --version | head -n1
        python3 --version
        
        echo "✓ Linux EDK2 build prerequisites installed"
      shell: bash

    # Linux Prerequisites (missing iasl and other EDK2 tools)
    - name: Setup Linux EDK2 Prerequisites
      if: matrix.os == 'linux'
      run: |
        echo "Installing EDK2 prerequisites for Linux..."
        
        # Update package lists
        sudo apt-get update
        
        # Install essential EDK2 build tools
        # Note: python3-distutils removed for Ubuntu 24.04 compatibility
        sudo apt-get install -y \
          build-essential \
          uuid-dev \
          iasl \
          acpica-tools \
          git \
          nasm \
          python-is-python3
        
        echo "✓ Linux EDK2 prerequisites installed"
        
        # Verify critical tools
        echo "Verifying installed tools..."
        gcc --version | head -n1
        nasm -v
        iasl -v || echo "iasl version check failed but tool is present"
        python3 --version
        
        echo "✓ Linux prerequisites setup completed"
      shell: bash

    # Ensure EDK2 submodules are properly initialized (all platforms)
    - name: Initialize EDK2 Submodules
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "Ensuring EDK2 submodules are properly initialized..."
        
        # Configure Git to use HTTPS for GitHub URLs to avoid SSH authentication issues
        git config --global url."https://github.com/".insteadOf "git@github.com:"
        git config --global url."https://".insteadOf "git://"
        
        # Set timeout for Git operations (reduce from default to fail faster)
        git config --global http.lowSpeedLimit 1000
        git config --global http.lowSpeedTime 30
        
        # The checkout action should have done this, but let's be explicit
        git submodule status | head -10
        
        # Check if critical submodules exist
        if [ ! -d "edk2" ]; then
          echo "edk2 directory not found yet - this will be created by build scripts"
        else
          echo "Checking EDK2 submodules in edk2..."
          cd edk2
          
          # Check for critical missing submodules
          missing_submodules=()
          
          if [ ! -d "MdePkg/Library/MipiSysTLib/mipisyst" ]; then
            missing_submodules+=("MipiSysTLib")
          fi
          
          if [ ! -d "BaseTools/Source/C/BrotliCompress/brotli" ]; then
            missing_submodules+=("BrotliCompress")
          fi
          
          if [ ! -d "CryptoPkg/Library/OpensslLib/openssl" ]; then
            missing_submodules+=("OpensslLib")
          fi
          
          if [ ${#missing_submodules[@]} -ne 0 ]; then
            echo "Missing submodules detected: ${missing_submodules[*]}"
            echo "Initializing missing submodules with HTTPS authentication..."
            
            # Ensure we use HTTPS URLs for submodules
            git config --local url."https://github.com/".insteadOf "git@github.com:"
            git config --local url."https://".insteadOf "git://"
            
            # Initialize with Git's built-in HTTP timeout settings
            git -c http.lowSpeedLimit=1000 -c http.lowSpeedTime=60 submodule update --init --recursive --progress || {
              echo "Submodule initialization failed, trying individual submodules..."
              for submodule in "${missing_submodules[@]}"; do
                echo "Initializing $submodule..."
                case $submodule in
                  "MipiSysTLib")
                    git -c http.lowSpeedLimit=1000 -c http.lowSpeedTime=30 submodule update --init --recursive MdePkg/Library/MipiSysTLib || echo "Failed to init MipiSysTLib"
                    ;;
                  "BrotliCompress")
                    git -c http.lowSpeedLimit=1000 -c http.lowSpeedTime=30 submodule update --init --recursive BaseTools/Source/C/BrotliCompress || echo "Failed to init BrotliCompress"
                    ;;
                  "OpensslLib")
                    git -c http.lowSpeedLimit=1000 -c http.lowSpeedTime=30 submodule update --init --recursive CryptoPkg/Library/OpensslLib || echo "Failed to init OpensslLib"
                    ;;
                esac
              done
            }
          else
            echo "✓ All critical submodules are present"
          fi
          
          # Verify submodules after initialization
          echo "Verifying submodule status after initialization..."
          if [ -d "MdePkg/Library/MipiSysTLib/mipisyst/library/include" ]; then
            echo "✓ MipiSysTLib verified: mipisyst/library/include exists"
          else
            echo "❌ MipiSysTLib verification failed: mipisyst/library/include missing"
            echo "Attempting direct MipiSysTLib initialization..."
            git submodule update --init --recursive MdePkg/Library/MipiSysTLib
            if [ -d "MdePkg/Library/MipiSysTLib/mipisyst/library/include" ]; then
              echo "✓ MipiSysTLib verified after direct init"
            else
              echo "❌ MipiSysTLib still missing after direct init"
            fi
          fi
          
          if [ -d "BaseTools/Source/C/BrotliCompress/brotli/c" ]; then
            echo "✓ BrotliCompress verified: brotli/c exists"
          else
            echo "❌ BrotliCompress verification failed: brotli/c missing"
          fi
          
          if [ -d "CryptoPkg/Library/OpensslLib/openssl/include" ]; then
            echo "✓ OpensslLib verified: openssl/include exists"
          else
            echo "❌ OpensslLib verification failed: openssl/include missing"
          fi
          
          cd ..
        fi
        
        echo "✓ Submodule check completed"
      shell: bash

    # Build with Traditional EDK2 (Linux/macOS)
    - name: Build with EDK2 (Linux/macOS)
      if: matrix.os != 'windows' && matrix.os != 'windows-cygwin'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        CI: true
      run: |
        echo "Building ACPIPatcher with simplified build system..."
        echo "Configuration: ${{ matrix.arch }} ${{ matrix.build_type }} (${{ matrix.toolchain }})"
        
        # Run our automated setup and build script with parameters
        chmod +x setup_and_build.sh
        ./setup_and_build.sh ${{ matrix.arch }} ${{ matrix.build_type }}
        
        echo "✅ Build completed successfully"
      shell: bash

    # Build EDK2 BaseTools (Windows)
    - name: Build EDK2 BaseTools (Windows)
      if: matrix.os == 'windows'
      shell: cmd
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        CI: false
        CL: /WX-
      run: |
        echo Building EDK2 BaseTools...
        cd edk2
        
        REM Call edksetup.bat with ForceRebuild to build BaseTools
        call edksetup.bat ForceRebuild
        
        if %ERRORLEVEL% NEQ 0 (
          echo BaseTools build failed with exit code %ERRORLEVEL%
          exit /b %ERRORLEVEL%
        )
        
        REM Verify BaseTools were built
        if exist "BaseTools\Bin\Win32\GenFw.exe" (
          echo ✅ BaseTools built successfully - GenFw.exe found
        ) else if exist "BaseTools\Source\C\bin\GenFw.exe" (
          echo ✅ BaseTools built successfully - GenFw.exe found in Source\C\bin
        ) else (
          echo ❌ BaseTools build verification failed - GenFw.exe not found
          exit /b 1
        )
        
        echo BaseTools build completed successfully

    # Build with Windows Batch Script (VS2022)
    - name: Build ACPIPatcher (Windows VS2022)
      if: matrix.os == 'windows'
      shell: cmd
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        CI: true
        CL: /WX-
      run: |
        echo Building ACPIPatcher with VS2022 toolchain...
        echo Configuration: ${{ matrix.arch }} ${{ matrix.build_type }} (${{ matrix.toolchain }})
        
        REM Use our automated Windows build script
        call setup_and_build.bat ${{ matrix.arch }} ${{ matrix.build_type }}
        
        if %ERRORLEVEL% NEQ 0 (
          echo Build failed with exit code %ERRORLEVEL%
          exit /b %ERRORLEVEL%
        )
        
        echo Build completed successfully

    # Build with Traditional EDK2 (Windows Cygwin)
    - name: Build with EDK2 (Windows Cygwin)
      if: matrix.os == 'windows-cygwin'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        CI: true
        CL: /WX-
      run: |
        Write-Host "Building ACPIPatcher with Cygwin GCC toolchain..."
        Write-Host "Configuration: ${{ matrix.arch }} ${{ matrix.build_type }} (${{ matrix.toolchain }})"
        
        # Force refresh PATH and add NASM
        $env:PATH = [System.Environment]::GetEnvironmentVariable("PATH","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("PATH","User")
        $env:PATH = "C:\tools\cygwin\bin;C:\Program Files\NASM;C:\ProgramData\chocolatey\lib\nasm\tools\nasm-2.16.03;" + $env:PATH
        
        # Verify tools are available
        Write-Host "Checking tools..."
        Get-Command nasm -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "NASM found: $($_.Source)" }
        if (Test-Path "C:\Program Files\NASM\nasm.exe") { 
          Write-Host "NASM version:"
          & "C:\Program Files\NASM\nasm.exe" -v 
        } elseif (Test-Path "C:\ProgramData\chocolatey\lib\nasm\tools\nasm-2.16.03\nasm.exe") {
          Write-Host "NASM version:"
          & "C:\ProgramData\chocolatey\lib\nasm\tools\nasm-2.16.03\nasm.exe" -v
        }
        & C:\tools\cygwin\bin\gcc.exe --version | Select-Object -First 1
        
        # Set Cygwin build flag
        $env:BASETOOLS_CYGWIN_BUILD = "TRUE"
        
        # Run our automated setup and build script with parameters
        & .\setup_and_build.bat ${{ matrix.arch }} ${{ matrix.build_type }}
        
        if ($LASTEXITCODE -eq 0) {
          Write-Host "✅ Build completed successfully"
        } else {
          Write-Host "❌ Build failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
      shell: pwsh

    # Upload Artifacts
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: ACPIPatcher-${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.build_type }}-${{ matrix.toolchain }}
        path: |
          *.efi
        retention-days: 30

    # Alternative Python Build Test (Windows only for now)
    - name: Test Python Build Script (Windows)
      if: matrix.os == 'windows' && matrix.arch == 'X64' && matrix.build_type == 'RELEASE'
      env:
        CI: true
      run: |
        Write-Host "Testing Python build script as alternative..."
        
        # Test our Python script with the same parameters
        python ACPIPatcher.py --build --arch ${{ matrix.arch }} --build-type ${{ matrix.build_type }}
        
        if ($LASTEXITCODE -eq 0) {
          Write-Host "✅ Python build script test completed successfully"
        } else {
          Write-Host "⚠ Python build script test failed (non-critical)"
        }
      shell: pwsh
      continue-on-error: true

    # Verify Build Success (Windows)
    - name: Verify Build Output (Windows)
      if: matrix.os == 'windows' || matrix.os == 'windows-cygwin'
      shell: cmd
      run: |
        echo Checking build outputs...
        
        REM Check for ACPIPatcher.efi
        if exist "ACPIPatcher.efi" (
          echo ACPIPatcher.efi found
          dir ACPIPatcher.efi
        ) else (
          echo ACPIPatcher.efi not found
        )
        
        REM Check for ACPIPatcherDxe.efi
        if exist "ACPIPatcherDxe.efi" (
          echo ACPIPatcherDxe.efi found
          dir ACPIPatcherDxe.efi
        ) else (
          echo ACPIPatcherDxe.efi not found
        )
        
        echo Build verification completed

    # Verify Build Success (Linux/macOS)
    - name: Verify Build Output (Linux/macOS)
      run: |
        echo "Checking build outputs..."
        if [ -f "ACPIPatcher.efi" ]; then
          echo "✅ ACPIPatcher.efi found ($(stat -f%z ACPIPatcher.efi 2>/dev/null || stat -c%s ACPIPatcher.efi) bytes)"
        else
          echo "❌ ACPIPatcher.efi not found"
        fi
        
        if [ -f "ACPIPatcherDxe.efi" ]; then
          echo "✅ ACPIPatcherDxe.efi found ($(stat -f%z ACPIPatcherDxe.efi 2>/dev/null || stat -c%s ACPIPatcherDxe.efi) bytes)"
        else
          echo "❌ ACPIPatcherDxe.efi not found"
        fi
        
        echo "Build verification completed"
      shell: bash
      if: matrix.os != 'windows' && matrix.os != 'windows-cygwin'
